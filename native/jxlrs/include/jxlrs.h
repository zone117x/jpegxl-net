/* 
 * jxlrs - C API for jxl-rs JPEG XL decoder
 * Auto-generated by cbindgen. Do not edit manually.
 */

#ifndef JXLRS_H
#define JXLRS_H

/* Warning: this file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Status codes returned by decoder functions.
 */
typedef enum JxlrsStatus {
    /**
     * Operation completed successfully.
     */
    JXLRS_STATUS_SUCCESS = 0,
    /**
     * An error occurred. Call `jxlrs_get_last_error` for details.
     */
    JXLRS_STATUS_ERROR = 1,
    /**
     * The decoder needs more input data.
     */
    JXLRS_STATUS_NEED_MORE_INPUT = 2,
    /**
     * Invalid argument passed to function.
     */
    JXLRS_STATUS_INVALID_ARGUMENT = 3,
    /**
     * Buffer too small for output.
     */
    JXLRS_STATUS_BUFFER_TOO_SMALL = 4,
    /**
     * Decoder is in an invalid state for this operation.
     */
    JXLRS_STATUS_INVALID_STATE = 5,
} JxlrsStatus;

/**
 * Pixel data format.
 */
typedef enum JxlrsDataFormat {
    /**
     * 8-bit unsigned integer per channel.
     */
    JXLRS_DATA_FORMAT_UINT8 = 0,
    /**
     * 16-bit unsigned integer per channel.
     */
    JXLRS_DATA_FORMAT_UINT16 = 1,
    /**
     * 16-bit float per channel.
     */
    JXLRS_DATA_FORMAT_FLOAT16 = 2,
    /**
     * 32-bit float per channel.
     */
    JXLRS_DATA_FORMAT_FLOAT32 = 3,
} JxlrsDataFormat;

/**
 * Color channel layout.
 */
typedef enum JxlrsColorType {
    /**
     * Single grayscale channel.
     */
    JXLRS_COLOR_TYPE_GRAYSCALE = 0,
    /**
     * Grayscale + alpha.
     */
    JXLRS_COLOR_TYPE_GRAYSCALE_ALPHA = 1,
    /**
     * Red, green, blue.
     */
    JXLRS_COLOR_TYPE_RGB = 2,
    /**
     * Red, green, blue, alpha.
     */
    JXLRS_COLOR_TYPE_RGBA = 3,
    /**
     * Blue, green, red (Windows bitmap order).
     */
    JXLRS_COLOR_TYPE_BGR = 4,
    /**
     * Blue, green, red, alpha.
     */
    JXLRS_COLOR_TYPE_BGRA = 5,
} JxlrsColorType;

/**
 * Endianness for multi-byte pixel formats.
 */
typedef enum JxlrsEndianness {
    /**
     * Use native endianness of the platform.
     */
    JXLRS_ENDIANNESS_NATIVE = 0,
    /**
     * Little endian byte order.
     */
    JXLRS_ENDIANNESS_LITTLE_ENDIAN = 1,
    /**
     * Big endian byte order.
     */
    JXLRS_ENDIANNESS_BIG_ENDIAN = 2,
} JxlrsEndianness;

/**
 * Image orientation (EXIF-style).
 */
typedef enum JxlrsOrientation {
    /**
     * Normal orientation.
     */
    JXLRS_ORIENTATION_IDENTITY = 1,
    /**
     * Flipped horizontally.
     */
    JXLRS_ORIENTATION_FLIP_HORIZONTAL = 2,
    /**
     * Rotated 180 degrees.
     */
    JXLRS_ORIENTATION_ROTATE180 = 3,
    /**
     * Flipped vertically.
     */
    JXLRS_ORIENTATION_FLIP_VERTICAL = 4,
    /**
     * Transposed (swap x/y) then flipped horizontally.
     */
    JXLRS_ORIENTATION_TRANSPOSE = 5,
    /**
     * Rotated 90 degrees clockwise.
     */
    JXLRS_ORIENTATION_ROTATE90_CW = 6,
    /**
     * Transposed then flipped vertically.
     */
    JXLRS_ORIENTATION_ANTI_TRANSPOSE = 7,
    /**
     * Rotated 90 degrees counter-clockwise.
     */
    JXLRS_ORIENTATION_ROTATE90_CCW = 8,
} JxlrsOrientation;

/**
 * Extra channel type.
 */
typedef enum JxlrsExtraChannelType {
    /**
     * Alpha/transparency channel.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_ALPHA = 0,
    /**
     * Depth map.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_DEPTH = 1,
    /**
     * Spot color.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_SPOT_COLOR = 2,
    /**
     * Selection mask.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_SELECTION_MASK = 3,
    /**
     * CFA (color filter array) for raw sensor data.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_CFA = 4,
    /**
     * Thermal data.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_THERMAL = 5,
    /**
     * Non-optional extra channel.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_NON_OPTIONAL = 6,
    /**
     * Optional extra channel.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_OPTIONAL = 7,
    /**
     * Unknown channel type.
     */
    JXLRS_EXTRA_CHANNEL_TYPE_UNKNOWN = 255,
} JxlrsExtraChannelType;

/**
 * Signature check result.
 */
typedef enum JxlrsSignature {
    /**
     * Not enough data to determine.
     */
    JXLRS_SIGNATURE_NOT_ENOUGH_BYTES = 0,
    /**
     * Not a JPEG XL file.
     */
    JXLRS_SIGNATURE_INVALID = 1,
    /**
     * Valid JPEG XL codestream.
     */
    JXLRS_SIGNATURE_CODESTREAM = 2,
    /**
     * Valid JPEG XL container.
     */
    JXLRS_SIGNATURE_CONTAINER = 3,
} JxlrsSignature;

/**
 * Opaque decoder handle.
 */
typedef struct JxlrsDecoder {
    uint8_t _private[0];
} JxlrsDecoder;

/**
 * Pixel format specification.
 */
typedef struct JxlrsPixelFormat {
    /**
     * Data format for each channel.
     */
    enum JxlrsDataFormat data_format;
    /**
     * Color channel layout.
     */
    enum JxlrsColorType color_type;
    /**
     * Endianness for formats > 8 bits.
     */
    enum JxlrsEndianness endianness;
} JxlrsPixelFormat;

/**
 * Basic image information.
 */
typedef struct JxlrsBasicInfo {
    /**
     * Image width in pixels.
     */
    uint32_t width;
    /**
     * Image height in pixels.
     */
    uint32_t height;
    /**
     * Bits per sample for integer formats.
     */
    uint32_t bits_per_sample;
    /**
     * Exponent bits (0 for integer formats, >0 for float).
     */
    uint32_t exponent_bits_per_sample;
    /**
     * Number of color channels (1 for grayscale, 3 for RGB).
     */
    uint32_t num_color_channels;
    /**
     * Number of extra channels (alpha, depth, etc.).
     */
    uint32_t num_extra_channels;
    /**
     * Whether alpha is premultiplied (0 = no, 1 = yes).
     */
    int32_t alpha_premultiplied;
    /**
     * Image orientation.
     */
    enum JxlrsOrientation orientation;
    /**
     * Whether the image has animation (0 = no, 1 = yes).
     */
    int32_t have_animation;
    /**
     * Animation ticks per second numerator (0 if no animation).
     */
    uint32_t animation_tps_numerator;
    /**
     * Animation ticks per second denominator (0 if no animation).
     */
    uint32_t animation_tps_denominator;
    /**
     * Number of animation loops (0 = infinite).
     */
    uint32_t animation_num_loops;
    /**
     * Whether original color profile is used (0 = no, 1 = yes).
     */
    int32_t uses_original_profile;
    /**
     * Preview image width (0 if no preview).
     */
    uint32_t preview_width;
    /**
     * Preview image height (0 if no preview).
     */
    uint32_t preview_height;
    /**
     * Intensity target for HDR (nits).
     */
    float intensity_target;
    /**
     * Minimum nits for tone mapping.
     */
    float min_nits;
} JxlrsBasicInfo;

/**
 * Information about an extra channel.
 */
typedef struct JxlrsExtraChannelInfo {
    /**
     * Type of extra channel.
     */
    enum JxlrsExtraChannelType channel_type;
    /**
     * Bits per sample.
     */
    uint32_t bits_per_sample;
    /**
     * Exponent bits (for float channels).
     */
    uint32_t exponent_bits_per_sample;
    /**
     * Whether alpha is premultiplied (only for alpha channels).
     */
    int32_t alpha_premultiplied;
    /**
     * Spot color values (RGBA, only for spot color channels).
     */
    float spot_color[4];
    /**
     * Channel name length in bytes (excluding null terminator).
     */
    uint32_t name_length;
} JxlrsExtraChannelInfo;

/**
 * Returns the library version as a packed integer.
 * Format: (major << 24) | (minor << 16) | (patch << 8)
 */
uint32_t jxlrs_version(void);

/**
 * Creates a new decoder instance.
 *
 * # Returns
 * A pointer to the decoder, or null on allocation failure.
 * The decoder must be destroyed with `jxlrs_decoder_destroy`.
 */
struct JxlrsDecoder *jxlrs_decoder_create(void);

/**
 * Destroys a decoder instance and frees its resources.
 *
 * # Safety
 * The decoder pointer must have been created by `jxlrs_decoder_create`.
 * After calling this function, the decoder pointer is invalid.
 */
void jxlrs_decoder_destroy(struct JxlrsDecoder *decoder);

/**
 * Resets the decoder to its initial state, allowing it to decode a new image.
 *
 * # Safety
 * The decoder pointer must be valid.
 */
enum JxlrsStatus jxlrs_decoder_reset(struct JxlrsDecoder *decoder);

/**
 * Sets the input data for the decoder (one-shot decoding).
 *
 * The decoder copies the data internally, so the caller can free
 * the input buffer after this call.
 *
 * # Safety
 * - `decoder` must be a valid decoder pointer.
 * - `data` must point to `size` readable bytes.
 */
enum JxlrsStatus jxlrs_decoder_set_input(struct JxlrsDecoder *decoder,
                                         const uint8_t *data,
                                         uintptr_t size);

/**
 * Sets the desired output pixel format.
 *
 * # Safety
 * The decoder pointer must be valid.
 */
enum JxlrsStatus jxlrs_decoder_set_pixel_format(struct JxlrsDecoder *decoder,
                                                const struct JxlrsPixelFormat *format);

/**
 * Decodes the image header and retrieves basic info.
 *
 * This must be called before `jxlrs_decoder_get_pixels`.
 *
 * # Safety
 * - `decoder` must be valid.
 * - `info` must point to a writable `JxlrsBasicInfo`.
 */
enum JxlrsStatus jxlrs_decoder_read_info(struct JxlrsDecoder *decoder,
                                         struct JxlrsBasicInfo *info);

/**
 * Gets the number of extra channels.
 *
 * Must be called after `jxlrs_decoder_read_info`.
 */
uint32_t jxlrs_decoder_get_extra_channel_count(const struct JxlrsDecoder *decoder);

/**
 * Gets info about an extra channel.
 *
 * # Safety
 * - `decoder` must be valid.
 * - `info` must point to a writable `JxlrsExtraChannelInfo`.
 * - `index` must be less than the extra channel count.
 */
enum JxlrsStatus jxlrs_decoder_get_extra_channel_info(const struct JxlrsDecoder *decoder,
                                                      uint32_t index,
                                                      struct JxlrsExtraChannelInfo *info);

/**
 * Calculates the required buffer size for decoded pixels.
 *
 * # Safety
 * `decoder` must be valid and `jxlrs_decoder_read_info` must have been called.
 */
uintptr_t jxlrs_decoder_get_buffer_size(const struct JxlrsDecoder *decoder);

/**
 * Decodes pixels into the provided buffer.
 *
 * # Arguments
 * * `decoder` - The decoder instance.
 * * `buffer` - Output buffer for pixel data.
 * * `buffer_size` - Size of the buffer in bytes.
 *
 * # Safety
 * - `decoder` must be valid.
 * - `buffer` must be valid for writes of `buffer_size` bytes.
 * - `jxlrs_decoder_read_info` must have been called first.
 */
enum JxlrsStatus jxlrs_decoder_get_pixels(struct JxlrsDecoder *decoder,
                                          uint8_t *buffer,
                                          uintptr_t buffer_size);

/**
 * Checks if data appears to be a JPEG XL file.
 *
 * Only needs the first 12 bytes to determine.
 *
 * # Safety
 * `data` must be valid for reads of `size` bytes.
 */
enum JxlrsSignature jxlrs_signature_check(const uint8_t *data,
                                          uintptr_t size);

/**
 * Gets the last error message.
 *
 * # Arguments
 * * `buffer` - Buffer to write the error message to.
 * * `buffer_size` - Size of the buffer in bytes.
 *
 * # Returns
 * The length of the error message (excluding null terminator).
 * If the buffer is too small, the message is truncated.
 * Returns 0 if there is no error message.
 *
 * # Safety
 * The buffer must be valid for writes of `buffer_size` bytes.
 */
uintptr_t jxlrs_get_last_error(char *buffer,
                               uintptr_t buffer_size);

/**
 * Clears the last error message.
 */
void jxlrs_clear_last_error(void);

#endif  /* JXLRS_H */
