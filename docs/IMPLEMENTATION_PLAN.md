# JpegXL.Net Implementation Plan

This document outlines the plan to wrap the `jxl-rs` Rust library in C# for .NET consumption.

## Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         JpegXL.Net (C#)                             │
│  ┌───────────────────┐  ┌─────────────────────────────────────────┐ │
│  │ High-level API    │  │ Source-generated P/Invoke bindings     │ │
│  │ JpegXLDecoder     │  │ NativeMethods.g.cs                      │ │
│  └───────────────────┘  └─────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    jxl_capi (Rust C-API layer)                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ #[no_mangle] extern "C" functions                             │  │
│  │ Opaque handle types                                           │  │
│  │ C-compatible structs                                          │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         jxl (Rust core)                             │
│  JxlDecoder, JxlBasicInfo, JxlPixelFormat, etc.                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Part 1: Creating a C-API for the Rust Library

### 1.1 Create a new `jxl_capi` crate

Create a new Rust crate that exposes C-compatible functions:

```
jxl-rs/
├── jxl_capi/
│   ├── Cargo.toml
│   ├── src/
│   │   ├── lib.rs
│   │   ├── decoder.rs
│   │   ├── types.rs
│   │   └── error.rs
│   └── cbindgen.toml
```

**Cargo.toml:**
```toml
[package]
name = "jxl_capi"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib", "staticlib"]

[dependencies]
jxl = { path = "../jxl" }

[build-dependencies]
cbindgen = "0.27"
```

### 1.2 Define C-compatible types

```rust
// types.rs
use std::ffi::c_void;

#[repr(C)]
pub struct JxlDecoderHandle {
    _private: [u8; 0],
}

#[repr(C)]
pub struct JxlBasicInfoC {
    pub width: u32,
    pub height: u32,
    pub bits_per_sample: u32,
    pub exponent_bits_per_sample: u32,
    pub num_color_channels: u32,
    pub num_extra_channels: u32,
    pub alpha_bits: u32,
    pub alpha_premultiplied: i32,
    pub have_animation: i32,
    pub orientation: u32,
}

#[repr(C)]
pub enum JxlStatus {
    Success = 0,
    Error = 1,
    NeedMoreInput = 2,
    BasicInfo = 3,
    FrameReady = 4,
    FullImage = 5,
}

#[repr(C)]
pub enum JxlPixelFormatC {
    Uint8 = 0,
    Uint16 = 1,
    Float16 = 2,
    Float32 = 3,
}

#[repr(C)]
pub enum JxlColorTypeC {
    Grayscale = 0,
    GrayscaleAlpha = 1,
    Rgb = 2,
    Rgba = 3,
}
```

### 1.3 Define C-API functions

```rust
// lib.rs
use std::ptr;
use std::slice;

/// Creates a new decoder instance.
#[no_mangle]
pub extern "C" fn jxl_decoder_create() -> *mut JxlDecoderHandle {
    // ...
}

/// Destroys a decoder instance.
#[no_mangle]
pub extern "C" fn jxl_decoder_destroy(decoder: *mut JxlDecoderHandle) {
    // ...
}

/// Feeds input data to the decoder.
#[no_mangle]
pub extern "C" fn jxl_decoder_process(
    decoder: *mut JxlDecoderHandle,
    data: *const u8,
    size: usize,
    bytes_consumed: *mut usize,
) -> JxlStatus {
    // ...
}

/// Gets basic image info.
#[no_mangle]
pub extern "C" fn jxl_decoder_get_basic_info(
    decoder: *const JxlDecoderHandle,
    info: *mut JxlBasicInfoC,
) -> JxlStatus {
    // ...
}

/// Decodes pixels into the provided buffer.
#[no_mangle]
pub extern "C" fn jxl_decoder_get_pixels(
    decoder: *mut JxlDecoderHandle,
    buffer: *mut u8,
    buffer_size: usize,
    pixel_format: JxlPixelFormatC,
    color_type: JxlColorTypeC,
) -> JxlStatus {
    // ...
}

/// Gets the last error message.
#[no_mangle]
pub extern "C" fn jxl_get_last_error(
    decoder: *const JxlDecoderHandle,
    buffer: *mut u8,
    buffer_size: usize,
) -> i32 {
    // ...
}
```

### 1.4 Generate C header with cbindgen

**cbindgen.toml:**
```toml
language = "C"
header = "/* Auto-generated by cbindgen. Do not edit. */"
include_guard = "JXL_CAPI_H"
autogen_warning = "/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */"

[export]
include = ["JxlStatus", "JxlBasicInfoC", "JxlPixelFormatC", "JxlColorTypeC"]

[fn]
prefix = "JXL_API"

[macro_expansion]
bitflags = true
```

**build.rs:**
```rust
fn main() {
    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    cbindgen::generate(&crate_dir)
        .expect("Unable to generate C bindings")
        .write_to_file("include/jxl_capi.h");
}
```

---

## Part 2: Cross-Platform Compilation

### 2.1 Target Platforms

| RID            | Rust Target                      | Library Name       |
|----------------|----------------------------------|--------------------|
| win-x64        | x86_64-pc-windows-msvc           | jxl_capi.dll       |
| win-x86        | i686-pc-windows-msvc             | jxl_capi.dll       |
| win-arm64      | aarch64-pc-windows-msvc          | jxl_capi.dll       |
| linux-x64      | x86_64-unknown-linux-gnu         | libjxl_capi.so     |
| linux-arm64    | aarch64-unknown-linux-gnu        | libjxl_capi.so     |
| osx-x64        | x86_64-apple-darwin              | libjxl_capi.dylib  |
| osx-arm64      | aarch64-apple-darwin             | libjxl_capi.dylib  |

### 2.2 Build Script (`build-native.sh`)

```bash
#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUTPUT_DIR="$SCRIPT_DIR/runtimes"

# Install cross for cross-compilation
cargo install cross --git https://github.com/cross-rs/cross

declare -A TARGETS=(
    ["win-x64"]="x86_64-pc-windows-gnu"
    ["win-x86"]="i686-pc-windows-gnu"
    ["win-arm64"]="aarch64-pc-windows-gnullvm"
    ["linux-x64"]="x86_64-unknown-linux-gnu"
    ["linux-arm64"]="aarch64-unknown-linux-gnu"
    ["osx-x64"]="x86_64-apple-darwin"
    ["osx-arm64"]="aarch64-apple-darwin"
)

declare -A LIB_NAMES=(
    ["win-x64"]="jxl_capi.dll"
    ["win-x86"]="jxl_capi.dll"
    ["win-arm64"]="jxl_capi.dll"
    ["linux-x64"]="libjxl_capi.so"
    ["linux-arm64"]="libjxl_capi.so"
    ["osx-x64"]="libjxl_capi.dylib"
    ["osx-arm64"]="libjxl_capi.dylib"
)

for RID in "${!TARGETS[@]}"; do
    TARGET="${TARGETS[$RID]}"
    LIB_NAME="${LIB_NAMES[$RID]}"
    
    echo "Building for $RID ($TARGET)..."
    
    if [[ "$RID" == osx-* ]]; then
        # macOS requires native compilation or special setup
        cargo build --release --target "$TARGET" -p jxl_capi
    else
        cross build --release --target "$TARGET" -p jxl_capi
    fi
    
    mkdir -p "$OUTPUT_DIR/$RID/native"
    cp "target/$TARGET/release/$LIB_NAME" "$OUTPUT_DIR/$RID/native/"
done

echo "Build complete!"
```

### 2.3 GitHub Actions Workflow (`.github/workflows/build-native.yml`)

```yaml
name: Build Native Libraries

on:
  push:
    tags: ["v*"]
  workflow_dispatch:

jobs:
  build-linux:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - rid: linux-x64
            target: x86_64-unknown-linux-gnu
          - rid: linux-arm64
            target: aarch64-unknown-linux-gnu
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Install cross
        run: cargo install cross --git https://github.com/cross-rs/cross
      - name: Build
        run: cross build --release --target ${{ matrix.target }} -p jxl_capi
        working-directory: jxl-rs
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: native-${{ matrix.rid }}
          path: jxl-rs/target/${{ matrix.target }}/release/libjxl_capi.so

  build-windows:
    runs-on: windows-latest
    strategy:
      matrix:
        include:
          - rid: win-x64
            target: x86_64-pc-windows-msvc
          - rid: win-x86
            target: i686-pc-windows-msvc
          - rid: win-arm64
            target: aarch64-pc-windows-msvc
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Build
        run: cargo build --release --target ${{ matrix.target }} -p jxl_capi
        working-directory: jxl-rs
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: native-${{ matrix.rid }}
          path: jxl-rs/target/${{ matrix.target }}/release/jxl_capi.dll

  build-macos:
    runs-on: macos-latest
    strategy:
      matrix:
        include:
          - rid: osx-x64
            target: x86_64-apple-darwin
          - rid: osx-arm64
            target: aarch64-apple-darwin
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Build
        run: cargo build --release --target ${{ matrix.target }} -p jxl_capi
        working-directory: jxl-rs
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: native-${{ matrix.rid }}
          path: jxl-rs/target/${{ matrix.target }}/release/libjxl_capi.dylib

  package:
    needs: [build-linux, build-windows, build-macos]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Organize runtimes
        run: |
          mkdir -p runtimes
          for dir in artifacts/native-*; do
            rid=$(basename "$dir" | sed 's/native-//')
            mkdir -p "runtimes/$rid/native"
            cp "$dir"/* "runtimes/$rid/native/"
          done
      - name: Upload combined runtimes
        uses: actions/upload-artifact@v4
        with:
          name: runtimes
          path: runtimes/
```

---

## Part 3: NuGet Package Structure

### 3.1 Package Layout

Native libraries must be placed in the `runtimes/{rid}/native/` folder:

```
JpegXL.Net.nupkg
├── lib/
│   ├── netstandard2.0/
│   │   └── JpegXL.Net.dll
│   └── net8.0/
│       └── JpegXL.Net.dll
├── runtimes/
│   ├── win-x64/
│   │   └── native/
│   │       └── jxl_capi.dll
│   ├── win-x86/
│   │   └── native/
│   │       └── jxl_capi.dll
│   ├── win-arm64/
│   │   └── native/
│   │       └── jxl_capi.dll
│   ├── linux-x64/
│   │   └── native/
│   │       └── libjxl_capi.so
│   ├── linux-arm64/
│   │   └── native/
│   │       └── libjxl_capi.so
│   ├── osx-x64/
│   │   └── native/
│   │       └── libjxl_capi.dylib
│   └── osx-arm64/
│       └── native/
│           └── libjxl_capi.dylib
└── JpegXL.Net.nuspec
```

### 3.2 Updated csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net8.0</TargetFrameworks>
    <!-- ... other properties ... -->
  </PropertyGroup>

  <!-- Include native libraries in the package -->
  <ItemGroup>
    <None Include="../runtimes/**/*" Pack="true" PackagePath="runtimes" />
  </ItemGroup>

  <!-- Ensure native libraries are copied to output -->
  <ItemGroup>
    <Content Include="../runtimes/**/*.dll" PackagePath="runtimes" Link="runtimes/%(RecursiveDir)%(Filename)%(Extension)">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="../runtimes/**/*.so" PackagePath="runtimes" Link="runtimes/%(RecursiveDir)%(Filename)%(Extension)">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
    <Content Include="../runtimes/**/*.dylib" PackagePath="runtimes" Link="runtimes/%(RecursiveDir)%(Filename)%(Extension)">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>
  </ItemGroup>

</Project>
```

### 3.3 Alternative: Separate Runtime Packages

For smaller downloads, split into multiple packages:

- `JpegXL.Net` - Core managed code only
- `JpegXL.Net.runtime.win-x64` - Windows x64 native
- `JpegXL.Net.runtime.linux-x64` - Linux x64 native
- etc.

Each runtime package uses `<RuntimeIdentifier>` in the csproj:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <PackageId>JpegXL.Net.runtime.win-x64</PackageId>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
  </PropertyGroup>
  <ItemGroup>
    <None Include="runtimes/win-x64/native/jxl_capi.dll" Pack="true" PackagePath="runtimes/win-x64/native/" />
  </ItemGroup>
</Project>
```

---

## Part 4: Source Generator for C# Interop

### 4.1 Overview

Use a source generator to automatically create P/Invoke bindings from:
1. The C header file generated by cbindgen, OR
2. A custom definition file (JSON/YAML)

### 4.2 Project Structure

```
src/
├── JpegXL.Net/
│   └── JpegXL.Net.csproj
├── JpegXL.Net.SourceGenerator/
│   ├── JpegXL.Net.SourceGenerator.csproj
│   ├── InteropGenerator.cs
│   └── CHeaderParser.cs
└── JpegXL.Net.Interop/
    ├── JpegXL.Net.Interop.csproj
    ├── jxl_capi.h              (input)
    └── NativeMethods.g.cs      (generated)
```

### 4.3 Source Generator Implementation

**JpegXL.Net.SourceGenerator.csproj:**
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
    <IsRoslynComponent>true</IsRoslynComponent>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" PrivateAssets="all" />
  </ItemGroup>
</Project>
```

**InteropGenerator.cs:**
```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

[Generator]
public class InteropGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find the C header file in additional files
        var headerFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".h"));

        context.RegisterSourceOutput(headerFiles, (ctx, file) =>
        {
            var content = file.GetText()?.ToString();
            if (content == null) return;

            var generated = GenerateInteropCode(content);
            ctx.AddSource("NativeMethods.g.cs", SourceText.From(generated, Encoding.UTF8));
        });
    }

    private string GenerateInteropCode(string headerContent)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.AppendLine("namespace JpegXL.Net.Interop;");
        sb.AppendLine();
        sb.AppendLine("internal static partial class NativeMethods");
        sb.AppendLine("{");
        sb.AppendLine("    private const string LibraryName = \"jxl_capi\";");
        sb.AppendLine();

        // Parse header and generate P/Invoke declarations
        // This is a simplified example - real implementation would use a proper C parser
        
        sb.AppendLine("    [LibraryImport(LibraryName, EntryPoint = \"jxl_decoder_create\")]");
        sb.AppendLine("    internal static partial IntPtr DecoderCreate();");
        sb.AppendLine();
        sb.AppendLine("    [LibraryImport(LibraryName, EntryPoint = \"jxl_decoder_destroy\")]");
        sb.AppendLine("    internal static partial void DecoderDestroy(IntPtr decoder);");
        sb.AppendLine();
        // ... more bindings
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }
}
```

### 4.4 Alternative: Use ClangSharpPInvokeGenerator

Instead of a custom source generator, use the ClangSharp tool:

```bash
# Install the tool
dotnet tool install --global ClangSharpPInvokeGenerator

# Generate bindings
ClangSharpPInvokeGenerator \
  --file jxl_capi.h \
  --namespace JpegXL.Net.Interop \
  --output NativeMethods.cs \
  --libraryPath jxl_capi \
  --methodClassName NativeMethods
```

### 4.5 Using LibraryImport (Modern .NET 7+)

For .NET 7+, use the built-in `LibraryImport` source generator:

```csharp
using System.Runtime.InteropServices;

namespace JpegXL.Net.Interop;

internal static partial class NativeMethods
{
    private const string LibraryName = "jxl_capi";

    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_create")]
    internal static partial IntPtr DecoderCreate();

    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_destroy")]
    internal static partial void DecoderDestroy(IntPtr decoder);

    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_process")]
    internal static partial JxlStatus DecoderProcess(
        IntPtr decoder,
        ReadOnlySpan<byte> data,
        nuint size,
        out nuint bytesConsumed);

    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_get_basic_info")]
    internal static partial JxlStatus DecoderGetBasicInfo(
        IntPtr decoder,
        out JxlBasicInfo info);

    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_get_pixels")]
    internal static partial JxlStatus DecoderGetPixels(
        IntPtr decoder,
        Span<byte> buffer,
        nuint bufferSize,
        JxlPixelFormat pixelFormat,
        JxlColorType colorType);
}
```

### 4.6 Netstandard2.0 Compatibility

For netstandard2.0, use `DllImport` instead of `LibraryImport`:

```csharp
#if NET7_0_OR_GREATER
    [LibraryImport(LibraryName, EntryPoint = "jxl_decoder_create")]
    internal static partial IntPtr DecoderCreate();
#else
    [DllImport(LibraryName, EntryPoint = "jxl_decoder_create")]
    internal static extern IntPtr DecoderCreate();
#endif
```

---

## Part 5: High-Level C# API

### 5.1 Safe Wrapper Classes

```csharp
namespace JpegXL.Net;

public sealed class JpegXLDecoder : IDisposable
{
    private IntPtr _handle;
    private bool _disposed;

    public JpegXLDecoder()
    {
        _handle = NativeMethods.DecoderCreate();
        if (_handle == IntPtr.Zero)
            throw new JpegXLException("Failed to create decoder");
    }

    public JpegXLBasicInfo DecodeHeader(ReadOnlySpan<byte> data)
    {
        // ...
    }

    public void DecodePixels(ReadOnlySpan<byte> data, Span<byte> output, JpegXLPixelFormat format)
    {
        // ...
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            if (_handle != IntPtr.Zero)
            {
                NativeMethods.DecoderDestroy(_handle);
                _handle = IntPtr.Zero;
            }
            _disposed = true;
        }
    }
}

public readonly record struct JpegXLBasicInfo(
    int Width,
    int Height,
    int BitsPerSample,
    int NumColorChannels,
    int NumExtraChannels,
    bool HasAlpha,
    bool HasAnimation,
    JpegXLOrientation Orientation);

public enum JpegXLPixelFormat
{
    Rgba8,
    Rgba16,
    RgbaF16,
    RgbaF32,
    Rgb8,
    // ...
}
```

---

## Part 6: Implementation Phases

### Phase 1: C-API Layer (Rust)
- [ ] Create `jxl_capi` crate
- [ ] Define C-compatible types
- [ ] Implement basic decoder functions
- [ ] Set up cbindgen for header generation
- [ ] Write unit tests for C-API

### Phase 2: Cross-Compilation Setup
- [ ] Set up GitHub Actions workflow
- [ ] Configure cross-compilation for all targets
- [ ] Test native library loading on each platform
- [ ] Create local build scripts

### Phase 3: NuGet Package
- [ ] Set up runtimes folder structure
- [ ] Update csproj for native library inclusion
- [ ] Test package on all platforms
- [ ] Consider split runtime packages for size

### Phase 4: C# Interop
- [ ] Choose approach: ClangSharp vs custom generator vs manual
- [ ] Generate/write P/Invoke bindings
- [ ] Handle netstandard2.0 vs net8.0 differences
- [ ] Write safe wrapper classes

### Phase 5: High-Level API
- [ ] Design public API surface
- [ ] Implement JpegXLDecoder
- [ ] Add streaming support
- [ ] Add async support
- [ ] Write comprehensive tests
- [ ] Write documentation

---

## Appendix: Recommended Tools

| Tool | Purpose |
|------|---------|
| [cbindgen](https://github.com/mozilla/cbindgen) | Generate C headers from Rust |
| [cross](https://github.com/cross-rs/cross) | Cross-compile Rust to multiple targets |
| [ClangSharp](https://github.com/dotnet/ClangSharp) | Generate C# from C headers |
| [NativeMemory](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.nativememory) | Safe native memory operations |
