// Copyright (c) the JPEG XL Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace JpegXL.Net.Generators;

/// <summary>
/// Source generator that creates public PascalCase wrapper types for internal snake_case FFI types.
/// Automatically discovers all Jxl* types in the JpegXL.Net.Native namespace.
/// </summary>
[Generator]
public class NativeTypeGenerator : IIncrementalGenerator
{
    private const string NativeNamespace = "JpegXL.Net.Native";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use the compilation directly to find all types
        context.RegisterSourceOutput(context.CompilationProvider, static (spc, compilation) =>
        {
            GenerateTypes(spc, compilation);
        });
    }

    private static void GenerateTypes(SourceProductionContext spc, Compilation compilation)
    {
        // Find the Native namespace
        var nativeNs = compilation.GetTypeByMetadataName($"{NativeNamespace}.NativeMethods")?.ContainingNamespace;
        if (nativeNs == null)
            return;

        // Collect all types to expose
        var structsToExpose = new List<INamedTypeSymbol>();
        var enumsToExpose = new List<INamedTypeSymbol>();

        // Find all types in the Native namespace
        foreach (var type in GetAllTypesInNamespace(nativeNs))
        {
            // Skip types that don't start with "Jxl"
            if (!type.Name.StartsWith("Jxl"))
                continue;

            // Skip compiler-generated types (like fixed buffer backing types)
            if (type.Name.Contains("<") || type.Name.Contains(">"))
                continue;

            if (type.TypeKind == TypeKind.Enum)
            {
                enumsToExpose.Add(type);
            }
            else if (type.TypeKind == TypeKind.Struct)
            {
                structsToExpose.Add(type);
            }
        }

        // Build config from discovered types
        var config = new GeneratorConfig(
            NativeNamespace,
            structsToExpose.Select(s => s.Name).ToArray(),
            enumsToExpose.Select(e => e.Name).ToArray()
        );

        // Generate public enums
        foreach (var enumType in enumsToExpose)
        {
            var source = GeneratePublicEnum(enumType);
            spc.AddSource($"{enumType.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        // Generate public structs
        foreach (var structType in structsToExpose)
        {
            var source = GeneratePublicStruct(structType, config);
            spc.AddSource($"{structType.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static IEnumerable<INamedTypeSymbol> GetAllTypesInNamespace(INamespaceSymbol ns)
    {
        foreach (var type in ns.GetTypeMembers())
        {
            yield return type;
        }
        
        foreach (var nestedNs in ns.GetNamespaceMembers())
        {
            foreach (var type in GetAllTypesInNamespace(nestedNs))
            {
                yield return type;
            }
        }
    }

    private static string GeneratePublicEnum(INamedTypeSymbol enumSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace JpegXL.Net;");
        sb.AppendLine();

        var underlyingType = enumSymbol.EnumUnderlyingType?.ToDisplayString() ?? "int";
        var xmlDoc = GetXmlDocSummary(enumSymbol);

        if (!string.IsNullOrEmpty(xmlDoc))
        {
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// {xmlDoc}");
            sb.AppendLine($"/// </summary>");
        }

        sb.AppendLine($"public enum {enumSymbol.Name} : {underlyingType}");
        sb.AppendLine("{");

        var members = enumSymbol.GetMembers().OfType<IFieldSymbol>().Where(f => f.HasConstantValue).ToArray();
        for (int i = 0; i < members.Length; i++)
        {
            var member = members[i];
            var memberDoc = GetXmlDocSummary(member);
            
            if (!string.IsNullOrEmpty(memberDoc))
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// {memberDoc}");
                sb.AppendLine($"    /// </summary>");
            }
            
            sb.Append($"    {member.Name} = {member.ConstantValue}");
            if (i < members.Length - 1)
                sb.AppendLine(",");
            else
                sb.AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GeneratePublicStruct(INamedTypeSymbol structSymbol, GeneratorConfig config)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace JpegXL.Net;");
        sb.AppendLine();

        var xmlDoc = GetXmlDocSummary(structSymbol);
        var internalTypeName = $"{config.SourceNamespace}.{structSymbol.Name}";

        // Collect all fields including fixed buffers
        var allMembers = structSymbol.GetMembers().ToArray();
        var allFields = allMembers
            .OfType<IFieldSymbol>()
            .Where(f => !f.IsStatic && !f.IsConst)
            .ToArray();
        
        var filteredFields = allFields
            .Where(f => !f.Name.StartsWith("_")) // Skip compiler-generated backing fields
            .ToArray();

        // Helper to detect fixed buffer fields (check both IsFixedSizeBuffer and FixedBufferAttribute)
        bool IsFixedBuffer(IFieldSymbol f) => 
            f.IsFixedSizeBuffer || 
            f.GetAttributes().Any(a => a.AttributeClass?.Name == "FixedBufferAttribute");

        // Regular fields
        var regularFields = filteredFields.Where(f => !IsFixedBuffer(f)).ToArray();
        
        // Fixed buffer fields
        var fixedBufferFields = filteredFields.Where(f => IsFixedBuffer(f)).ToArray();
        
        // If there are fixed buffers, we can't be a readonly struct (can't use fixed on readonly)
        var hasFixedBuffers = fixedBufferFields.Length > 0;

        if (!string.IsNullOrEmpty(xmlDoc))
        {
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// {xmlDoc}");
            sb.AppendLine($"/// </summary>");
        }

        if (hasFixedBuffers)
        {
            sb.AppendLine($"public partial struct {structSymbol.Name}");
        }
        else
        {
            sb.AppendLine($"public readonly partial struct {structSymbol.Name}");
        }
        sb.AppendLine("{");

        // Private field holding the internal struct
        if (hasFixedBuffers)
        {
            sb.AppendLine($"    private {internalTypeName} _native;");
        }
        else
        {
            sb.AppendLine($"    private readonly {internalTypeName} _native;");
        }
        sb.AppendLine();

        // Internal constructor from native
        sb.AppendLine($"    internal {structSymbol.Name}({internalTypeName} native) => _native = native;");
        sb.AppendLine();

        foreach (var field in regularFields)
        {
            var fieldDoc = GetXmlDocSummary(field);
            var publicName = SnakeToPascalCase(field.Name);
            var fieldType = field.Type.ToDisplayString();
            var isBoolField = fieldType == "int" && IsBooleanLikeField(field.Name);

            if (!string.IsNullOrEmpty(fieldDoc))
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// {fieldDoc}");
                sb.AppendLine($"    /// </summary>");
            }

            if (isBoolField)
            {
                sb.AppendLine($"    public bool {publicName} => _native.{field.Name} != 0;");
            }
            else
            {
                // Check if this is an internal enum type that we're also exposing
                var mappedType = MapToPublicType(fieldType, config);
                if (mappedType != fieldType)
                {
                    sb.AppendLine($"    public {mappedType} {publicName} => ({mappedType})_native.{field.Name};");
                }
                else
                {
                    sb.AppendLine($"    public {fieldType} {publicName} => _native.{field.Name};");
                }
            }
            sb.AppendLine();
        }

        // Generate safe accessors for fixed buffer fields
        foreach (var field in fixedBufferFields)
        {
            var fieldDoc = GetXmlDocSummary(field);
            var publicName = SnakeToPascalCase(field.Name);
            
            // For fixed buffers, we need to find the element type and size
            string? elementType = null;
            int fixedSize = 0;
            
            // Try to get from FixedBufferAttribute
            foreach (var attr in field.GetAttributes())
            {
                if (attr.AttributeClass?.Name == "FixedBufferAttribute" &&
                    attr.ConstructorArguments.Length >= 2)
                {
                    // First arg is the element type, second is the size
                    if (attr.ConstructorArguments[0].Value is ITypeSymbol typeArg)
                    {
                        elementType = typeArg.ToDisplayString();
                    }
                    var sizeArg = attr.ConstructorArguments[1];
                    if (sizeArg.Value is int intSize)
                        fixedSize = intSize;
                    else if (sizeArg.Value is uint uintSize)
                        fixedSize = (int)uintSize;
                    else if (sizeArg.Value != null && int.TryParse(sizeArg.Value.ToString(), out int parsed))
                        fixedSize = parsed;
                    break;
                }
            }
            
            // Fallback: try to get from pointer type (for compiled metadata)
            if (elementType == null && field.Type is IPointerTypeSymbol pointerType)
            {
                elementType = pointerType.PointedAtType.ToDisplayString();
            }
            
            // Fallback: look at the field's type for generated buffer struct
            // The compiler generates a nested struct like <spot_color>e__FixedBuffer with a field FixedElementField
            if (elementType == null && field.Type is INamedTypeSymbol namedType)
            {
                var elementField = namedType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .FirstOrDefault(f => f.Name == "FixedElementField");
                if (elementField != null)
                {
                    elementType = elementField.Type.ToDisplayString();
                }
            }
            
            // Get fixed size from reflection if not found via attribute
            if (fixedSize == 0)
            {
                fixedSize = GetFixedBufferSize(field);
            }
            
            if (elementType != null && fixedSize > 0)
            {
                if (!string.IsNullOrEmpty(fieldDoc))
                {
                    sb.AppendLine($"    /// <summary>");
                    sb.AppendLine($"    /// {fieldDoc}");
                    sb.AppendLine($"    /// </summary>");
                }
                
                // For fixed buffers, we need to copy to an array since we can't use fixed on readonly fields
                sb.AppendLine($"    public {elementType}[] {publicName}");
                sb.AppendLine($"    {{");
                sb.AppendLine($"        get");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            var result = new {elementType}[{fixedSize}];");
                sb.AppendLine($"            unsafe");
                sb.AppendLine($"            {{");
                sb.AppendLine($"                fixed ({elementType}* ptr = _native.{field.Name})");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    for (int i = 0; i < {fixedSize}; i++) result[i] = ptr[i];");
                sb.AppendLine($"                }}");
                sb.AppendLine($"            }}");
                sb.AppendLine($"            return result;");
                sb.AppendLine($"        }}");
                sb.AppendLine($"    }}");
                sb.AppendLine();
            }
        }

        // Add internal accessor for interop (returns a copy since we can't ref readonly a field of a readonly struct)
        sb.AppendLine($"    /// <summary>Gets the underlying native struct for advanced interop.</summary>");
        sb.AppendLine($"    internal {internalTypeName} Native => _native;");

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string MapToPublicType(string internalType, GeneratorConfig config)
    {
        // Check if this type is in our enums list
        foreach (var enumName in config.Enums)
        {
            var internalEnumType = $"{config.SourceNamespace}.{enumName}";
            if (internalType == internalEnumType)
            {
                return $"JpegXL.Net.{enumName}";
            }
        }
        return internalType;
    }

    private static bool IsBooleanLikeField(string fieldName)
    {
        return fieldName.StartsWith("have_") ||
               fieldName.StartsWith("has_") ||
               fieldName.StartsWith("is_") ||
               fieldName.StartsWith("uses_") ||
               fieldName.EndsWith("_premultiplied") ||
               fieldName == "alpha_premultiplied";
    }

    private static int GetFixedBufferSize(IFieldSymbol field)
    {
        // Try attribute first
        foreach (var attr in field.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "FixedBufferAttribute" &&
                attr.ConstructorArguments.Length >= 2)
            {
                var sizeArg = attr.ConstructorArguments[1];
                if (sizeArg.Value is int intSize)
                    return intSize;
                if (sizeArg.Value is uint uintSize)
                    return (int)uintSize;
                if (sizeArg.Value != null && int.TryParse(sizeArg.Value.ToString(), out int parsedSize))
                    return parsedSize;
            }
        }
        
        // For fixed buffers from source, try to get size from syntax
        foreach (var syntaxRef in field.DeclaringSyntaxReferences)
        {
            var syntax = syntaxRef.GetSyntax();
            // Look for fixed buffer declaration: public fixed float spot_color[4];
            var syntaxText = syntax.ToString();
            var match = System.Text.RegularExpressions.Regex.Match(syntaxText, @"\[(\d+)\]");
            if (match.Success && int.TryParse(match.Groups[1].Value, out int size))
            {
                return size;
            }
        }
        
        return 0;
    }

    private static string SnakeToPascalCase(string snakeCase)
    {
        var parts = snakeCase.Split('_');
        var sb = new StringBuilder();
        foreach (var part in parts)
        {
            if (part.Length > 0)
            {
                sb.Append(char.ToUpperInvariant(part[0]));
                if (part.Length > 1)
                    sb.Append(part.Substring(1).ToLowerInvariant());
            }
        }
        return sb.ToString();
    }

    private static string? GetXmlDocSummary(ISymbol symbol)
    {
        var xml = symbol.GetDocumentationCommentXml();
        if (string.IsNullOrEmpty(xml))
            return null;

        var match = Regex.Match(xml, @"<summary>\s*(.*?)\s*</summary>", RegexOptions.Singleline);
        if (match.Success)
        {
            var summary = match.Groups[1].Value.Trim();
            summary = Regex.Replace(summary, @"\s+", " ");
            // Escape XML entities
            summary = summary.Replace("&lt;", "<").Replace("&gt;", ">");
            return summary;
        }

        return null;
    }

    private record GeneratorConfig(string SourceNamespace, string[] Structs, string[] Enums);
}
