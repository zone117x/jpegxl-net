// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace JpegXL.Net
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "jxl_ffi";





        /// <summary>
        ///  Returns the library version as a packed integer.
        ///  Format: (major &lt;&lt; 24) | (minor &lt;&lt; 16) | (patch &lt;&lt; 8)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_version();

        /// <summary>
        ///  Creates a new decoder instance with default options.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeDecoderHandle* jxl_decoder_create();

        /// <summary>
        ///  Creates a new decoder instance with the specified options.
        ///
        ///  This is the preferred way to create a decoder with custom options.
        ///  Options are immutable after creation for efficiency.
        ///
        ///  # Arguments
        ///  * `options` - Pointer to decoder options, or null to use defaults.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        ///
        ///  # Safety
        ///  If `options` is not null, it must point to a valid `JxlDecodeOptions` struct.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create_with_options", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeDecoderHandle* jxl_decoder_create_with_options(JxlDecodeOptions* options);

        /// <summary>
        ///  Destroys a decoder instance and frees its resources.
        ///
        ///  # Safety
        ///  The decoder pointer must have been created by `jxl_decoder_create`.
        ///  After calling this function, the decoder pointer is invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_destroy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_decoder_destroy(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Resets the decoder to its initial state, allowing it to decode a new image.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_reset(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Rewinds the decoder to the beginning of the input without clearing the data buffer.
        ///  This allows re-decoding the same input without calling SetInput again.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_rewind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_rewind(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Appends input data to the decoder's buffer.
        ///
        ///  The decoder copies the data internally, so the caller can free
        ///  the input buffer after this call. Does not reset decoder state,
        ///  allowing incremental feeding of data.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `data` must point to `size` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_append_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_append_input(NativeDecoderHandle* decoder, byte* data, System.UIntPtr size);

        /// <summary>
        ///  Sets input data by reading directly from a file.
        ///
        ///  This is more efficient than reading the file in managed code and then
        ///  calling `jxl_decoder_append_input`, as it avoids an intermediate copy.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `path` must be a valid null-terminated UTF-8 string.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_input_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_set_input_file(NativeDecoderHandle* decoder, byte* path);

        /// <summary>
        ///  Processes the current input data and returns the next decoder event.
        ///
        ///  This is the main function for streaming decoding. Call it repeatedly,
        ///  handling each event appropriately:
        ///  - `NeedMoreInput`: Call `jxl_decoder_append_input` with more data
        ///  - `HaveBasicInfo`: Image info is available, call `jxl_decoder_get_basic_info`
        ///  - `HaveFrameHeader`: Frame header is available, call `jxl_decoder_get_frame_header`
        ///  - `NeedOutputBuffer`: Ready to decode pixels, call `jxl_decoder_read_pixels`
        ///  - `FrameComplete`: Frame is done, check for more frames or call again
        ///  - `Complete`: All frames decoded, decoding is finished
        ///  - `Error`: Check `jxl_get_last_error` for details
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_process", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_process(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the basic image info (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlBasicInfoRaw`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_basic_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_basic_info(NativeDecoderHandle* decoder, JxlBasicInfoRaw* info);

        /// <summary>
        ///  Gets the current frame header (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveFrameHeader`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `header` must point to a writable `JxlFrameHeader`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_frame_header", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_frame_header(NativeDecoderHandle* decoder, JxlFrameHeader* header);

        /// <summary>
        ///  Gets the current frame's name.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveFrameHeader`.
        ///  Returns the number of bytes written to buffer, or the required size if buffer is null/too small.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `buffer` - Output buffer for the UTF-8 name, or null to query required size.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The number of bytes written, or the required buffer size if buffer is null or too small.
        ///  Returns 0 if no frame header is available or the frame has no name.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - If `buffer` is not null, it must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_frame_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_frame_name(NativeDecoderHandle* decoder, byte* buffer, uint buffer_size);

        /// <summary>
        ///  Decodes pixels into the provided buffer (streaming API).
        ///
        ///  Call this after `jxl_decoder_process` returns `NeedOutputBuffer`.
        ///  After successful completion, call `jxl_decoder_process` again to
        ///  get `FrameComplete` or continue with the next frame.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `buffer` must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_read_pixels(NativeDecoderHandle* decoder, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Checks if the decoder has more frames to decode.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_has_more_frames", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_decoder_has_more_frames(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Skips the current frame without decoding pixels.
        ///
        ///  Call this after `jxl_decoder_process` returns `NeedOutputBuffer` when you
        ///  only need frame metadata (duration, name, etc.) and don't need the pixels.
        ///  This is much faster than `jxl_decoder_read_pixels` as it doesn't decode
        ///  pixel data.
        ///
        ///  After successful completion, call `jxl_decoder_process` again to
        ///  get `FrameComplete` or continue with the next frame.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_skip_frame", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_skip_frame(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Calculates the required buffer size for a specific extra channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - The extra channel index (0-based).
        ///
        ///  # Returns
        ///  The required buffer size in bytes, or 0 if invalid.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_decoder_get_extra_channel_buffer_size(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Decodes pixels with extra channels into separate buffers.
        ///
        ///  The first buffer receives color data (RGB/RGBA/etc.), subsequent buffers
        ///  receive extra channels in order. Set buffer to null to skip that channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `color_buffer` - Output buffer for color data.
        ///  * `color_buffer_size` - Size of color buffer in bytes.
        ///  * `extra_buffers` - Array of pointers to extra channel buffers (can contain nulls to skip).
        ///  * `extra_buffer_sizes` - Array of buffer sizes for each extra channel.
        ///  * `num_extra_buffers` - Number of extra buffers provided.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `color_buffer` must be valid for writes of `color_buffer_size` bytes.
        ///  - `extra_buffers` must point to `num_extra_buffers` pointers.
        ///  - Each non-null buffer must be valid for writes of its corresponding size.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels_with_extra_channels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_read_pixels_with_extra_channels(NativeDecoderHandle* decoder, byte* color_buffer, System.UIntPtr color_buffer_size, byte** extra_buffers, System.UIntPtr* extra_buffer_sizes, System.UIntPtr num_extra_buffers);

        /// <summary>
        ///  Sets the desired output pixel format.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_pixel_format", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_set_pixel_format(NativeDecoderHandle* decoder, JxlPixelFormat* format);

        /// <summary>
        ///  Gets the number of extra channels.
        ///
        ///  Must be called after basic info is available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_extra_channel_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets info about an extra channel.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlExtraChannelInfo`.
        ///  - `index` must be less than the extra channel count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_extra_channel_info(NativeDecoderHandle* decoder, uint index, JxlExtraChannelInfo* info);

        /// <summary>
        ///  Calculates the required buffer size for decoded pixels.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_decoder_get_buffer_size(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the embedded color profile from the image.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `profile_out` - Output for the profile raw data.
        ///  * `icc_data_out` - Output pointer for ICC data (only set if profile is ICC type).
        ///  * `handle_out` - Output for the profile handle (for calling helper methods).
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `profile_out` must point to a writable `JxlColorProfileRaw`.
        ///  - `icc_data_out` must point to a writable pointer.
        ///  - `handle_out` must point to a writable pointer.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_embedded_color_profile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_embedded_color_profile(NativeDecoderHandle* decoder, JxlColorProfileRaw* profile_out, byte** icc_data_out, JxlColorProfileHandle** handle_out);

        /// <summary>
        ///  Gets the current output color profile.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Safety
        ///  Same as `jxl_decoder_get_embedded_color_profile`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_output_color_profile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_output_color_profile(NativeDecoderHandle* decoder, JxlColorProfileRaw* profile_out, byte** icc_data_out, JxlColorProfileHandle** handle_out);

        /// <summary>
        ///  Sets the output color profile for decoding.
        ///
        ///  Must be called after `HaveBasicInfo` and before decoding pixels.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `profile` - The color profile raw data.
        ///  * `icc_data` - ICC data pointer (required if profile tag is Icc).
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `profile` must point to a valid `JxlColorProfileRaw`.
        ///  - If profile is ICC, `icc_data` must point to `profile.IccLength` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_output_color_profile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_set_output_color_profile(NativeDecoderHandle* decoder, JxlColorProfileRaw* profile, byte* icc_data);

        /// <summary>
        ///  Frees a color profile handle.
        ///
        ///  # Safety
        ///  The handle must have been created by a color profile function.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_color_profile_free(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Clones a color profile handle.
        ///
        ///  # Returns
        ///  A new handle that must be freed with `jxl_color_profile_free`, or null on failure.
        ///
        ///  # Safety
        ///  The handle must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_clone", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlColorProfileHandle* jxl_color_profile_clone(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Attempts to get ICC profile data from a color profile.
        ///
        ///  Returns true if ICC data is available (either native or converted).
        ///
        ///  # Arguments
        ///  * `handle` - The color profile handle.
        ///  * `data_out` - Output pointer for ICC data.
        ///  * `length_out` - Output for ICC data length.
        ///
        ///  # Safety
        ///  - `handle` must be valid.
        ///  - `data_out` and `length_out` must be writable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_try_as_icc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_color_profile_try_as_icc(JxlColorProfileHandle* handle, byte** data_out, System.UIntPtr* length_out);

        /// <summary>
        ///  Gets the number of color channels for a profile.
        ///
        ///  # Returns
        ///  1 for grayscale, 3 for RGB, 4 for CMYK.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_channels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_color_profile_channels(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Checks if a profile represents a CMYK color space.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_is_cmyk", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_color_profile_is_cmyk(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Checks if the decoder can output to this profile without a CMS.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_can_output_to", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_color_profile_can_output_to(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Checks if two profiles represent the same color encoding.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_same_color_encoding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_color_profile_same_color_encoding(JxlColorProfileHandle* handle_a, JxlColorProfileHandle* handle_b);

        /// <summary>
        ///  Creates a copy of a profile with linear transfer function.
        ///
        ///  # Returns
        ///  A new handle, or null if not possible (e.g., for ICC profiles).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_with_linear_tf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlColorProfileHandle* jxl_color_profile_with_linear_tf(JxlColorProfileHandle* handle);

        /// <summary>
        ///  Gets the transfer function from a simple color profile.
        ///
        ///  # Returns
        ///  True if the profile has a transfer function, false otherwise (ICC or XYB).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_get_transfer_function", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_color_profile_get_transfer_function(JxlColorProfileHandle* handle, JxlTransferFunctionRaw* tf_out);

        /// <summary>
        ///  Gets the string representation of a color profile.
        ///
        ///  # Arguments
        ///  * `handle` - The color profile handle.
        ///  * `buffer` - Output buffer for the string, or null to query required size.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The number of bytes written (excluding null terminator), or required size if buffer is null/too small.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_color_profile_to_string(JxlColorProfileHandle* handle, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Gets the description string for a color encoding.
        ///
        ///  This returns human-readable names like "sRGB", "DisplayP3", "Rec2100PQ" for known
        ///  profiles, or a detailed encoding string for custom profiles.
        ///
        ///  # Returns
        ///  The number of bytes written, or required size if buffer is null/too small.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_encoding_get_description", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_color_encoding_get_description(JxlColorEncodingRaw* encoding, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Creates a color profile handle from a simple color encoding.
        ///
        ///  # Returns
        ///  A new handle that must be freed with `jxl_color_profile_free`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_from_encoding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlColorProfileHandle* jxl_color_profile_from_encoding(JxlColorEncodingRaw* encoding);

        /// <summary>
        ///  Creates a color profile handle from ICC data.
        ///
        ///  # Safety
        ///  `icc_data` must point to `icc_length` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_profile_from_icc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlColorProfileHandle* jxl_color_profile_from_icc(byte* icc_data, System.UIntPtr icc_length);

        /// <summary>
        ///  Creates a standard sRGB color encoding.
        ///
        ///  # Arguments
        ///  * `grayscale` - If true, creates grayscale sRGB; otherwise RGB sRGB.
        ///  * `encoding_out` - Output for the encoding data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_encoding_srgb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_color_encoding_srgb([MarshalAs(UnmanagedType.U1)] bool grayscale, JxlColorEncodingRaw* encoding_out);

        /// <summary>
        ///  Creates a linear sRGB color encoding.
        ///
        ///  # Arguments
        ///  * `grayscale` - If true, creates grayscale linear sRGB; otherwise RGB linear sRGB.
        ///  * `encoding_out` - Output for the encoding data.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_color_encoding_linear_srgb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_color_encoding_linear_srgb([MarshalAs(UnmanagedType.U1)] bool grayscale, JxlColorEncodingRaw* encoding_out);

        /// <summary>
        ///  Gets the number of EXIF boxes in the image.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Returns
        ///  The number of EXIF boxes, or 0 if none or not accessible.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_exif_box_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_exif_box_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the number of XML/XMP boxes in the image.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Returns
        ///  The number of XML boxes, or 0 if none or not accessible.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_xml_box_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_xml_box_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the number of JUMBF boxes in the image.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Returns
        ///  The number of JUMBF boxes, or 0 if none or not accessible.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_jumbf_box_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_jumbf_box_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets EXIF data from a specific box by index.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///  The returned pointer is valid until the decoder is reset, rewound, or freed.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance (mutable for caching).
        ///  * `index` - Zero-based box index.
        ///  * `data_out` - Output pointer for EXIF data bytes.
        ///  * `length_out` - Output for EXIF data length.
        ///  * `is_brotli_compressed` - Output for brotli compression flag (true if brob box).
        ///
        ///  # Returns
        ///  - `Success` if EXIF data is available.
        ///  - `InvalidState` if called before basic info is available.
        ///  - `InvalidArgument` if index is out of range.
        ///  - `Error` if no EXIF data exists in the image.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - Output pointers must be writable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_exif_box_at", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_exif_box_at(NativeDecoderHandle* decoder, uint index, byte** data_out, System.UIntPtr* length_out, bool* is_brotli_compressed);

        /// <summary>
        ///  Gets XML/XMP data from a specific box by index.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///  The returned pointer is valid until the decoder is reset, rewound, or freed.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance (mutable for caching).
        ///  * `index` - Zero-based box index.
        ///  * `data_out` - Output pointer for XML data bytes.
        ///  * `length_out` - Output for XML data length.
        ///  * `is_brotli_compressed` - Output for brotli compression flag (true if brob box).
        ///
        ///  # Returns
        ///  - `Success` if XML data is available.
        ///  - `InvalidState` if called before basic info is available.
        ///  - `InvalidArgument` if index is out of range.
        ///  - `Error` if no XML data exists in the image.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - Output pointers must be writable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_xml_box_at", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_xml_box_at(NativeDecoderHandle* decoder, uint index, byte** data_out, System.UIntPtr* length_out, bool* is_brotli_compressed);

        /// <summary>
        ///  Gets JUMBF data from a specific box by index.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///  The returned pointer is valid until the decoder is reset, rewound, or freed.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance (mutable for caching).
        ///  * `index` - Zero-based box index.
        ///  * `data_out` - Output pointer for JUMBF data bytes.
        ///  * `length_out` - Output for JUMBF data length.
        ///  * `is_brotli_compressed` - Output for brotli compression flag (true if brob box).
        ///
        ///  # Returns
        ///  - `Success` if JUMBF data is available.
        ///  - `InvalidState` if called before basic info is available.
        ///  - `InvalidArgument` if index is out of range.
        ///  - `Error` if no JUMBF data exists in the image.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - Output pointers must be writable.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_jumbf_box_at", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_jumbf_box_at(NativeDecoderHandle* decoder, uint index, byte** data_out, System.UIntPtr* length_out, bool* is_brotli_compressed);

        /// <summary>
        ///  Returns whether the EXIF box at the given index is brotli-compressed.
        ///
        ///  Only valid after `jxl_decoder_get_exif_box_at` has been called to populate the cache.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - Zero-based box index.
        ///
        ///  # Returns
        ///  - `true` if the box was brotli-compressed in the file (brob box).
        ///  - `false` if uncompressed or if cache not populated.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_is_exif_box_compressed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_decoder_is_exif_box_compressed(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Returns whether the XML box at the given index is brotli-compressed.
        ///
        ///  Only valid after `jxl_decoder_get_xml_box_at` has been called to populate the cache.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - Zero-based box index.
        ///
        ///  # Returns
        ///  - `true` if the box was brotli-compressed in the file (brob box).
        ///  - `false` if uncompressed or if cache not populated.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_is_xml_box_compressed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_decoder_is_xml_box_compressed(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Returns whether the JUMBF box at the given index is brotli-compressed.
        ///
        ///  Only valid after `jxl_decoder_get_jumbf_box_at` has been called to populate the cache.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - Zero-based box index.
        ///
        ///  # Returns
        ///  - `true` if the box was brotli-compressed in the file (brob box).
        ///  - `false` if uncompressed or if cache not populated.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_is_jumbf_box_compressed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_decoder_is_jumbf_box_compressed(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Checks if data appears to be a JPEG XL file.
        ///
        ///  Only needs the first 12 bytes to determine.
        ///
        ///  # Safety
        ///  `data` must be valid for reads of `size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_signature_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlSignature jxl_signature_check(byte* data, System.UIntPtr size);

        /// <summary>
        ///  Gets the last error message.
        ///
        ///  # Arguments
        ///  * `buffer` - Buffer to write the error message to.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The length of the error message (excluding null terminator).
        ///  If the buffer is too small, the message is truncated.
        ///  Returns 0 if there is no error message.
        ///
        ///  # Safety
        ///  The buffer must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_get_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_get_last_error(byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Clears the last error message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_clear_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_clear_last_error();


    }

    /// <summary>
    ///  Opaque decoder handle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct NativeDecoderHandle
    {
        public fixed byte _private[1];
    }

    /// <summary>
    ///  Pixel format specification.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlPixelFormat
    {
        /// <summary>
        ///  Data format for each channel.
        /// </summary>
        public JxlDataFormat DataFormat;
        /// <summary>
        ///  Color channel layout.
        /// </summary>
        public JxlColorType ColorType;
        /// <summary>
        ///  Endianness for formats &gt; 8 bits.
        /// </summary>
        public JxlEndianness Endianness;
    }

    /// <summary>
    ///  Tone mapping parameters for HDR content.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlToneMapping
    {
        /// <summary>
        ///  Intensity target for HDR (nits).
        /// </summary>
        public float IntensityTarget;
        /// <summary>
        ///  Minimum nits for tone mapping.
        /// </summary>
        public float MinNits;
        /// <summary>
        ///  Linear tone mapping threshold (nits, or ratio if relative_to_max_display).
        /// </summary>
        public float LinearBelow;
        /// <summary>
        ///  Whether linear_below is relative to max display luminance.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool RelativeToMaxDisplay;
    }

    /// <summary>
    ///  Bit depth specification.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlBitDepth
    {
        /// <summary>
        ///  Whether this is integer or floating-point.
        /// </summary>
        public JxlBitDepthType Type;
        /// <summary>
        ///  Number of bits per sample.
        /// </summary>
        public uint BitsPerSample;
        /// <summary>
        ///  Number of exponent bits (0 for integer formats).
        /// </summary>
        public uint ExponentBitsPerSample;
    }

    /// <summary>
    ///  Animation parameters for an animated JPEG XL image.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlAnimation
    {
        /// <summary>
        ///  Ticks per second numerator.
        /// </summary>
        public uint TpsNumerator;
        /// <summary>
        ///  Ticks per second denominator.
        /// </summary>
        public uint TpsDenominator;
        /// <summary>
        ///  Number of loops (0 = infinite).
        /// </summary>
        public uint NumLoops;
        /// <summary>
        ///  Whether frames have individual timecodes.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool HaveTimecodes;
    }

    /// <summary>
    ///  Basic image information (raw FFI struct).
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlBasicInfoRaw
    {
        /// <summary>
        ///  Image width in pixels.
        /// </summary>
        public uint Width;
        /// <summary>
        ///  Image height in pixels.
        /// </summary>
        public uint Height;
        /// <summary>
        ///  Bit depth specification.
        /// </summary>
        public JxlBitDepth BitDepth;
        /// <summary>
        ///  Number of extra channels (alpha, depth, etc.).
        /// </summary>
        public uint NumExtraChannels;
        /// <summary>
        ///  Animation parameters (all zeros if not animated).
        /// </summary>
        public JxlAnimation Animation;
        /// <summary>
        ///  Preview image width (0 if no preview).
        /// </summary>
        public uint Preview_Width;
        /// <summary>
        ///  Preview image height (0 if no preview).
        /// </summary>
        public uint Preview_Height;
        /// <summary>
        ///  Tone mapping parameters for HDR content.
        /// </summary>
        public JxlToneMapping ToneMapping;
        /// <summary>
        ///  Image orientation.
        /// </summary>
        public JxlOrientation Orientation;
        /// <summary>
        ///  Whether alpha is premultiplied.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AlphaPremultiplied;
        /// <summary>
        ///  Whether the image is animated.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool IsAnimated;
        /// <summary>
        ///  Whether original color profile is used.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool UsesOriginalProfile;
    }

    /// <summary>
    ///  Information about an extra channel.
    ///  Note: jxl-rs API only exposes channel type and alpha_associated.
    ///  Other fields like bits_per_sample, name, spot_color are in the lower-level
    ///  ExtraChannelInfo but not exposed through the public API.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlExtraChannelInfo
    {
        /// <summary>
        ///  Type of extra channel.
        /// </summary>
        public JxlExtraChannelType ChannelType;
        /// <summary>
        ///  Whether alpha is associated/premultiplied (only for alpha channels).
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AlphaAssociated;
    }

    /// <summary>
    ///  Frame header information.
    ///  Note: jxl-rs API exposes name, duration, and size.
    ///  is_last is in the lower-level FrameHeader but not exposed through the API.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlFrameHeader
    {
        /// <summary>
        ///  Frame duration in milliseconds (for animation).
        /// </summary>
        public float DurationMs;
        /// <summary>
        ///  Frame width in pixels.
        /// </summary>
        public uint FrameWidth;
        /// <summary>
        ///  Frame height in pixels.
        /// </summary>
        public uint FrameHeight;
        /// <summary>
        ///  Frame name length in bytes. Use jxl_decoder_get_frame_name to get the actual name.
        /// </summary>
        public uint NameLength;
    }

    /// <summary>
    ///  Options for capturing metadata boxes during container parsing.
    ///  All capture flags default to true to match legacy behavior.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlMetadataCaptureOptions
    {
        /// <summary>
        ///  Whether to capture EXIF metadata boxes.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool CaptureExif;
        /// <summary>
        ///  Whether to capture XML/XMP metadata boxes.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool CaptureXml;
        /// <summary>
        ///  Whether to capture JUMBF metadata boxes.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool CaptureJumbf;
        /// <summary>
        ///  Maximum aggregate size in bytes for all EXIF boxes.
        ///  0 = no limit.
        /// </summary>
        public ulong ExifSizeLimit;
        /// <summary>
        ///  Maximum aggregate size in bytes for all XML boxes.
        ///  0 = no limit.
        /// </summary>
        public ulong XmlSizeLimit;
        /// <summary>
        ///  Maximum aggregate size in bytes for all JUMBF boxes.
        ///  0 = no limit.
        /// </summary>
        public ulong JumbfSizeLimit;
    }

    /// <summary>
    ///  Decoder options.
    ///  All options should be set before decoding begins.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlDecodeOptions
    {
        /// <summary>
        ///  Maximum number of pixels to decode.
        ///  0 = no limit.
        /// </summary>
        public System.UIntPtr PixelLimit;
        /// <summary>
        ///  Progressive decoding mode.
        /// </summary>
        public JxlProgressiveMode ProgressiveMode;
        /// <summary>
        ///  Desired display luminance for HDR→SDR tone mapping, in cd/m² (nits).
        ///  0 = no tone mapping (default). Typical SDR value: 203 (ITU-R BT.2408 reference white).
        ///  When set to a positive value and the image has a higher intensity target,
        ///  BT.2446 Method A tone mapping compresses the HDR luminance range.
        /// </summary>
        public float DesiredIntensityTarget;
        /// <summary>
        ///  Whether to adjust image orientation based on EXIF data.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AdjustOrientation;
        /// <summary>
        ///  Whether to render spot colors.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool RenderSpotColors;
        /// <summary>
        ///  Whether to coalesce animation frames.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool Coalescing;
        /// <summary>
        ///  Whether to skip the preview image.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool SkipPreview;
        /// <summary>
        ///  Whether to use high precision mode for decoding.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool HighPrecision;
        /// <summary>
        ///  Whether to premultiply alpha in the output.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool PremultiplyAlpha;
        /// <summary>
        ///  Whether to decode extra channels into separate buffers.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool DecodeExtraChannels;
        /// <summary>
        ///  Desired output pixel format.
        /// </summary>
        public JxlPixelFormat PixelFormat;
        /// <summary>
        ///  Options for capturing metadata boxes (EXIF, XML, JUMBF).
        /// </summary>
        public JxlMetadataCaptureOptions MetadataCapture;
        /// <summary>
        ///  Color management system to use for color space conversions.
        /// </summary>
        public JxlCmsType CmsType;
    }

    /// <summary>
    ///  Opaque handle to a color profile.
    ///  Must be freed with `jxl_color_profile_free`.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlColorProfileHandle
    {
        public fixed byte _private[1];
    }

    /// <summary>
    ///  White point specification (tagged union).
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlWhitePointRaw
    {
        /// <summary>
        ///  Discriminator tag.
        /// </summary>
        public JxlWhitePointTag Tag;
        /// <summary>
        ///  X chromaticity coordinate (only valid when Tag == Chromaticity).
        /// </summary>
        public float Wx;
        /// <summary>
        ///  Y chromaticity coordinate (only valid when Tag == Chromaticity).
        /// </summary>
        public float Wy;
    }

    /// <summary>
    ///  Color primaries specification (tagged union).
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlPrimariesRaw
    {
        /// <summary>
        ///  Discriminator tag.
        /// </summary>
        public JxlPrimariesTag Tag;
        /// <summary>
        ///  Red X chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float Rx;
        /// <summary>
        ///  Red Y chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float Ry;
        /// <summary>
        ///  Green X chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float Gx;
        /// <summary>
        ///  Green Y chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float Gy;
        /// <summary>
        ///  Blue X chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float Bx;
        /// <summary>
        ///  Blue Y chromaticity (only valid when Tag == Chromaticities).
        /// </summary>
        public float By;
    }

    /// <summary>
    ///  Transfer function specification (tagged union).
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlTransferFunctionRaw
    {
        /// <summary>
        ///  Discriminator tag.
        /// </summary>
        public JxlTransferFunctionTag Tag;
        /// <summary>
        ///  Gamma value (only valid when Tag == Gamma).
        /// </summary>
        public float Gamma;
    }

    /// <summary>
    ///  Color encoding specification (tagged union).
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlColorEncodingRaw
    {
        /// <summary>
        ///  Discriminator tag.
        /// </summary>
        public JxlColorEncodingTag Tag;
        /// <summary>
        ///  White point (valid for Rgb and Grayscale).
        /// </summary>
        public JxlWhitePointRaw WhitePoint;
        /// <summary>
        ///  Color primaries (only valid for Rgb).
        /// </summary>
        public JxlPrimariesRaw Primaries;
        /// <summary>
        ///  Transfer function (valid for Rgb and Grayscale, not Xyb).
        /// </summary>
        public JxlTransferFunctionRaw TransferFunction;
        /// <summary>
        ///  Rendering intent.
        /// </summary>
        public JxlRenderingIntent RenderingIntent;
    }

    /// <summary>
    ///  Color profile specification (tagged union).
    ///  For ICC profiles, the data is returned separately via pointer/length.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlColorProfileRaw
    {
        /// <summary>
        ///  Discriminator tag.
        /// </summary>
        public JxlColorProfileTag Tag;
        /// <summary>
        ///  ICC data length in bytes (only valid when Tag == Icc).
        /// </summary>
        public System.UIntPtr IccLength;
        /// <summary>
        ///  Color encoding (only valid when Tag == Simple).
        /// </summary>
        public JxlColorEncodingRaw Encoding;
    }


    /// <summary>
    ///  Status codes returned by decoder functions.
    /// </summary>
    public enum JxlStatus : uint
    {
        /// <summary>
        ///  Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 1,
        /// <summary>
        ///  The decoder needs more input data.
        /// </summary>
        NeedMoreInput = 2,
        /// <summary>
        ///  Invalid argument passed to function.
        /// </summary>
        InvalidArgument = 3,
        /// <summary>
        ///  Buffer too small for output.
        /// </summary>
        BufferTooSmall = 4,
        /// <summary>
        ///  Decoder is in an invalid state for this operation.
        /// </summary>
        InvalidState = 5,
        /// <summary>
        ///  An I/O error occurred (e.g., file not found).
        /// </summary>
        IoError = 6,
    }

    /// <summary>
    ///  Pixel data format.
    /// </summary>
    public enum JxlDataFormat : uint
    {
        /// <summary>
        ///  8-bit unsigned integer per channel.
        /// </summary>
        Uint8 = 0,
        /// <summary>
        ///  16-bit unsigned integer per channel.
        /// </summary>
        Uint16 = 1,
        /// <summary>
        ///  16-bit float per channel.
        /// </summary>
        Float16 = 2,
        /// <summary>
        ///  32-bit float per channel.
        /// </summary>
        Float32 = 3,
    }

    /// <summary>
    ///  Color channel layout.
    /// </summary>
    public enum JxlColorType : uint
    {
        /// <summary>
        ///  Red, green, blue, alpha (default for C# struct initialization).
        /// </summary>
        Rgba = 0,
        /// <summary>
        ///  Single grayscale channel.
        /// </summary>
        Grayscale = 1,
        /// <summary>
        ///  Grayscale + alpha.
        /// </summary>
        GrayscaleAlpha = 2,
        /// <summary>
        ///  Red, green, blue.
        /// </summary>
        Rgb = 3,
        /// <summary>
        ///  Blue, green, red (Windows bitmap order).
        /// </summary>
        Bgr = 4,
        /// <summary>
        ///  Blue, green, red, alpha.
        /// </summary>
        Bgra = 5,
    }

    /// <summary>
    ///  Endianness for multi-byte pixel formats.
    /// </summary>
    public enum JxlEndianness : uint
    {
        /// <summary>
        ///  Use native endianness of the platform.
        /// </summary>
        Native = 0,
        /// <summary>
        ///  Little endian byte order.
        /// </summary>
        LittleEndian = 1,
        /// <summary>
        ///  Big endian byte order.
        /// </summary>
        BigEndian = 2,
    }

    /// <summary>
    ///  Image orientation (EXIF-style).
    /// </summary>
    public enum JxlOrientation : uint
    {
        /// <summary>
        ///  Normal orientation.
        /// </summary>
        Identity = 1,
        /// <summary>
        ///  Flipped horizontally.
        /// </summary>
        FlipHorizontal = 2,
        /// <summary>
        ///  Rotated 180 degrees.
        /// </summary>
        Rotate180 = 3,
        /// <summary>
        ///  Flipped vertically.
        /// </summary>
        FlipVertical = 4,
        /// <summary>
        ///  Transposed (swap x/y) then flipped horizontally.
        /// </summary>
        Transpose = 5,
        /// <summary>
        ///  Rotated 90 degrees clockwise.
        /// </summary>
        Rotate90Cw = 6,
        /// <summary>
        ///  Transposed then flipped vertically.
        /// </summary>
        AntiTranspose = 7,
        /// <summary>
        ///  Rotated 90 degrees counter-clockwise.
        /// </summary>
        Rotate90Ccw = 8,
    }

    /// <summary>
    ///  Progressive decoding mode.
    /// </summary>
    public enum JxlProgressiveMode : uint
    {
        /// <summary>
        ///  Renders all pixels in every call to Process.
        /// </summary>
        Eager = 0,
        /// <summary>
        ///  Renders pixels once passes are completed.
        /// </summary>
        Pass = 1,
        /// <summary>
        ///  Renders pixels only once the final frame is ready.
        /// </summary>
        FullFrame = 2,
    }

    /// <summary>
    ///  Bit depth type discriminator.
    /// </summary>
    public enum JxlBitDepthType : uint
    {
        /// <summary>
        ///  Integer bit depth (e.g., 8-bit, 16-bit).
        /// </summary>
        Int = 0,
        /// <summary>
        ///  Floating-point bit depth (e.g., float16, float32).
        /// </summary>
        Float = 1,
    }

    /// <summary>
    ///  Extra channel type.
    /// </summary>
    public enum JxlExtraChannelType : uint
    {
        /// <summary>
        ///  Alpha/transparency channel.
        /// </summary>
        Alpha = 0,
        /// <summary>
        ///  Depth map.
        /// </summary>
        Depth = 1,
        /// <summary>
        ///  Spot color.
        /// </summary>
        SpotColor = 2,
        /// <summary>
        ///  Selection mask.
        /// </summary>
        SelectionMask = 3,
        /// <summary>
        ///  CFA (color filter array) for raw sensor data.
        /// </summary>
        Cfa = 4,
        /// <summary>
        ///  Thermal data.
        /// </summary>
        Thermal = 5,
        /// <summary>
        ///  Non-optional extra channel.
        /// </summary>
        NonOptional = 6,
        /// <summary>
        ///  Optional extra channel.
        /// </summary>
        Optional = 7,
        /// <summary>
        ///  Unknown channel type.
        /// </summary>
        Unknown = 255,
    }

    /// <summary>
    ///  Events returned by the streaming decoder's process function.
    ///  These indicate what stage the decoder has reached.
    /// </summary>
    public enum JxlDecoderEvent : uint
    {
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 0,
        /// <summary>
        ///  The decoder needs more input data. Call `jxl_decoder_append_input`.
        /// </summary>
        NeedMoreInput = 1,
        /// <summary>
        ///  Basic image info is now available. Call `jxl_decoder_get_basic_info`.
        /// </summary>
        HaveBasicInfo = 2,
        /// <summary>
        ///  Frame header is available. Call `jxl_decoder_get_frame_header`.
        /// </summary>
        HaveFrameHeader = 3,
        /// <summary>
        ///  Pixels are available. Call `jxl_decoder_read_pixels` with a buffer.
        /// </summary>
        NeedOutputBuffer = 4,
        /// <summary>
        ///  A frame has been fully decoded.
        /// </summary>
        FrameComplete = 5,
        /// <summary>
        ///  All frames have been decoded. The decoder is finished.
        /// </summary>
        Complete = 6,
    }

    /// <summary>
    ///  Signature check result.
    /// </summary>
    public enum JxlSignature : uint
    {
        /// <summary>
        ///  Not enough data to determine.
        /// </summary>
        NotEnoughBytes = 0,
        /// <summary>
        ///  Not a JPEG XL file.
        /// </summary>
        Invalid = 1,
        /// <summary>
        ///  Valid JPEG XL codestream.
        /// </summary>
        Codestream = 2,
        /// <summary>
        ///  Valid JPEG XL container.
        /// </summary>
        Container = 3,
    }

    /// <summary>
    ///  Rendering intent for color management.
    /// </summary>
    public enum JxlRenderingIntent : uint
    {
        /// <summary>
        ///  Perceptual rendering intent.
        /// </summary>
        Perceptual = 0,
        /// <summary>
        ///  Relative colorimetric rendering intent.
        /// </summary>
        Relative = 1,
        /// <summary>
        ///  Saturation rendering intent.
        /// </summary>
        Saturation = 2,
        /// <summary>
        ///  Absolute colorimetric rendering intent.
        /// </summary>
        Absolute = 3,
    }

    /// <summary>
    ///  Tag for JxlWhitePointRaw discriminated union.
    /// </summary>
    public enum JxlWhitePointTag : uint
    {
        /// <summary>
        ///  D65 standard illuminant.
        /// </summary>
        D65 = 0,
        /// <summary>
        ///  Equal energy illuminant.
        /// </summary>
        E = 1,
        /// <summary>
        ///  DCI-P3 theater white point.
        /// </summary>
        Dci = 2,
        /// <summary>
        ///  Custom chromaticity coordinates.
        /// </summary>
        Chromaticity = 3,
    }

    /// <summary>
    ///  Tag for JxlPrimariesRaw discriminated union.
    /// </summary>
    public enum JxlPrimariesTag : uint
    {
        /// <summary>
        ///  sRGB/Rec.709 primaries.
        /// </summary>
        Srgb = 0,
        /// <summary>
        ///  BT.2100/Rec.2020 primaries.
        /// </summary>
        Bt2100 = 1,
        /// <summary>
        ///  DCI-P3 primaries.
        /// </summary>
        P3 = 2,
        /// <summary>
        ///  Custom chromaticity coordinates.
        /// </summary>
        Chromaticities = 3,
    }

    /// <summary>
    ///  Tag for JxlTransferFunctionRaw discriminated union.
    /// </summary>
    public enum JxlTransferFunctionTag : uint
    {
        /// <summary>
        ///  BT.709 transfer function.
        /// </summary>
        Bt709 = 0,
        /// <summary>
        ///  Linear (gamma 1.0).
        /// </summary>
        Linear = 1,
        /// <summary>
        ///  sRGB transfer function.
        /// </summary>
        Srgb = 2,
        /// <summary>
        ///  Perceptual Quantizer (HDR).
        /// </summary>
        Pq = 3,
        /// <summary>
        ///  DCI gamma (~2.6).
        /// </summary>
        Dci = 4,
        /// <summary>
        ///  Hybrid Log-Gamma (HDR).
        /// </summary>
        Hlg = 5,
        /// <summary>
        ///  Custom gamma value.
        /// </summary>
        Gamma = 6,
    }

    /// <summary>
    ///  Tag for JxlColorEncodingRaw discriminated union.
    /// </summary>
    public enum JxlColorEncodingTag : uint
    {
        /// <summary>
        ///  RGB color space.
        /// </summary>
        Rgb = 0,
        /// <summary>
        ///  Grayscale color space.
        /// </summary>
        Grayscale = 1,
        /// <summary>
        ///  XYB color space (JPEG XL internal).
        /// </summary>
        Xyb = 2,
    }

    /// <summary>
    ///  Tag for JxlColorProfileRaw discriminated union.
    /// </summary>
    public enum JxlColorProfileTag : uint
    {
        /// <summary>
        ///  ICC profile (raw bytes).
        /// </summary>
        Icc = 0,
        /// <summary>
        ///  Simple parameterized color encoding.
        /// </summary>
        Simple = 1,
    }

    /// <summary>
    ///  Color Management System type.
    ///
    ///  Specifies which CMS implementation to use for color space conversions
    ///  during decoding. Without a CMS, the decoder can only output to color
    ///  profiles that match the image's internal encoding.
    /// </summary>
    public enum JxlCmsType : uint
    {
        /// <summary>
        ///  No CMS. Color space conversion is limited to built-in transforms.
        /// </summary>
        None = 0,
        /// <summary>
        ///  Use lcms2 (Little CMS) for color management.
        ///  Enables conversion between arbitrary ICC color profiles.
        /// </summary>
        Lcms2 = 1,
    }


}
