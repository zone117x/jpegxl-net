// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace JpegXL.Net
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "jxl_ffi";





        /// <summary>
        ///  Returns the library version as a packed integer.
        ///  Format: (major &lt;&lt; 24) | (minor &lt;&lt; 16) | (patch &lt;&lt; 8)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_version();

        /// <summary>
        ///  Creates a new decoder instance with default options.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeDecoderHandle* jxl_decoder_create();

        /// <summary>
        ///  Creates a new decoder instance with the specified options.
        ///
        ///  This is the preferred way to create a decoder with custom options.
        ///  Options are immutable after creation for efficiency.
        ///
        ///  # Arguments
        ///  * `options` - Pointer to decoder options, or null to use defaults.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        ///
        ///  # Safety
        ///  If `options` is not null, it must point to a valid `JxlDecodeOptions` struct.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create_with_options", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern NativeDecoderHandle* jxl_decoder_create_with_options(JxlDecodeOptions* options);

        /// <summary>
        ///  Destroys a decoder instance and frees its resources.
        ///
        ///  # Safety
        ///  The decoder pointer must have been created by `jxl_decoder_create`.
        ///  After calling this function, the decoder pointer is invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_destroy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_decoder_destroy(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Resets the decoder to its initial state, allowing it to decode a new image.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_reset(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Appends input data to the decoder's buffer.
        ///
        ///  The decoder copies the data internally, so the caller can free
        ///  the input buffer after this call. Does not reset decoder state,
        ///  allowing incremental feeding of data.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `data` must point to `size` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_append_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_append_input(NativeDecoderHandle* decoder, byte* data, System.UIntPtr size);

        /// <summary>
        ///  Processes the current input data and returns the next decoder event.
        ///
        ///  This is the main function for streaming decoding. Call it repeatedly,
        ///  handling each event appropriately:
        ///  - `NeedMoreInput`: Call `jxl_decoder_append_input` with more data
        ///  - `HaveBasicInfo`: Image info is available, call `jxl_decoder_get_basic_info`
        ///  - `HaveFrameHeader`: Frame header is available, call `jxl_decoder_get_frame_header`
        ///  - `NeedOutputBuffer`: Ready to decode pixels, call `jxl_decoder_read_pixels`
        ///  - `FrameComplete`: Frame is done, check for more frames or call again
        ///  - `Complete`: All frames decoded, decoding is finished
        ///  - `Error`: Check `jxl_get_last_error` for details
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_process", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_process(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the basic image info (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlBasicInfo`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_basic_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_basic_info(NativeDecoderHandle* decoder, JxlBasicInfo* info);

        /// <summary>
        ///  Gets the current frame header (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveFrameHeader`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `header` must point to a writable `JxlFrameHeader`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_frame_header", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_frame_header(NativeDecoderHandle* decoder, JxlFrameHeader* header);

        /// <summary>
        ///  Gets the current frame's name.
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveFrameHeader`.
        ///  Returns the number of bytes written to buffer, or the required size if buffer is null/too small.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `buffer` - Output buffer for the UTF-8 name, or null to query required size.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The number of bytes written, or the required buffer size if buffer is null or too small.
        ///  Returns 0 if no frame header is available or the frame has no name.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - If `buffer` is not null, it must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_frame_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_frame_name(NativeDecoderHandle* decoder, byte* buffer, uint buffer_size);

        /// <summary>
        ///  Decodes pixels into the provided buffer (streaming API).
        ///
        ///  Call this after `jxl_decoder_process` returns `NeedOutputBuffer`.
        ///  After successful completion, call `jxl_decoder_process` again to
        ///  get `FrameComplete` or continue with the next frame.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `buffer` must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_read_pixels(NativeDecoderHandle* decoder, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Checks if the decoder has more frames to decode.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_has_more_frames", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool jxl_decoder_has_more_frames(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Skips the current frame without decoding pixels.
        ///
        ///  Call this after `jxl_decoder_process` returns `NeedOutputBuffer` when you
        ///  only need frame metadata (duration, name, etc.) and don't need the pixels.
        ///  This is much faster than `jxl_decoder_read_pixels` as it doesn't decode
        ///  pixel data.
        ///
        ///  After successful completion, call `jxl_decoder_process` again to
        ///  get `FrameComplete` or continue with the next frame.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_skip_frame", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_skip_frame(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Calculates the required buffer size for a specific extra channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - The extra channel index (0-based).
        ///
        ///  # Returns
        ///  The required buffer size in bytes, or 0 if invalid.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_decoder_get_extra_channel_buffer_size(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Decodes pixels with extra channels into separate buffers.
        ///
        ///  The first buffer receives color data (RGB/RGBA/etc.), subsequent buffers
        ///  receive extra channels in order. Set buffer to null to skip that channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `color_buffer` - Output buffer for color data.
        ///  * `color_buffer_size` - Size of color buffer in bytes.
        ///  * `extra_buffers` - Array of pointers to extra channel buffers (can contain nulls to skip).
        ///  * `extra_buffer_sizes` - Array of buffer sizes for each extra channel.
        ///  * `num_extra_buffers` - Number of extra buffers provided.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `color_buffer` must be valid for writes of `color_buffer_size` bytes.
        ///  - `extra_buffers` must point to `num_extra_buffers` pointers.
        ///  - Each non-null buffer must be valid for writes of its corresponding size.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels_with_extra_channels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlDecoderEvent jxl_decoder_read_pixels_with_extra_channels(NativeDecoderHandle* decoder, byte* color_buffer, System.UIntPtr color_buffer_size, byte** extra_buffers, System.UIntPtr* extra_buffer_sizes, System.UIntPtr num_extra_buffers);

        /// <summary>
        ///  Sets the desired output pixel format.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_pixel_format", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_set_pixel_format(NativeDecoderHandle* decoder, JxlPixelFormat* format);

        /// <summary>
        ///  Gets the number of extra channels.
        ///
        ///  Must be called after basic info is available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint jxl_decoder_get_extra_channel_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets info about an extra channel.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlExtraChannelInfo`.
        ///  - `index` must be less than the extra channel count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlStatus jxl_decoder_get_extra_channel_info(NativeDecoderHandle* decoder, uint index, JxlExtraChannelInfo* info);

        /// <summary>
        ///  Calculates the required buffer size for decoded pixels.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_decoder_get_buffer_size(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Checks if data appears to be a JPEG XL file.
        ///
        ///  Only needs the first 12 bytes to determine.
        ///
        ///  # Safety
        ///  `data` must be valid for reads of `size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_signature_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern JxlSignature jxl_signature_check(byte* data, System.UIntPtr size);

        /// <summary>
        ///  Gets the last error message.
        ///
        ///  # Arguments
        ///  * `buffer` - Buffer to write the error message to.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The length of the error message (excluding null terminator).
        ///  If the buffer is too small, the message is truncated.
        ///  Returns 0 if there is no error message.
        ///
        ///  # Safety
        ///  The buffer must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_get_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern System.UIntPtr jxl_get_last_error(byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Clears the last error message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_clear_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void jxl_clear_last_error();


    }

    /// <summary>
    ///  Opaque decoder handle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct NativeDecoderHandle
    {
        public fixed byte _private[1];
    }

    /// <summary>
    ///  Pixel format specification.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlPixelFormat
    {
        /// <summary>
        ///  Data format for each channel.
        /// </summary>
        public JxlDataFormat DataFormat;
        /// <summary>
        ///  Color channel layout.
        /// </summary>
        public JxlColorType ColorType;
        /// <summary>
        ///  Endianness for formats &gt; 8 bits.
        /// </summary>
        public JxlEndianness Endianness;
    }

    /// <summary>
    ///  Basic image information.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlBasicInfo
    {
        /// <summary>
        ///  Image width in pixels.
        /// </summary>
        public uint Width;
        /// <summary>
        ///  Image height in pixels.
        /// </summary>
        public uint Height;
        /// <summary>
        ///  Bits per sample for integer formats.
        /// </summary>
        public uint BitsPerSample;
        /// <summary>
        ///  Exponent bits (0 for integer formats, &gt;0 for float).
        /// </summary>
        public uint ExponentBitsPerSample;
        /// <summary>
        ///  Number of color channels (1 for grayscale, 3 for RGB).
        /// </summary>
        public uint NumColorChannels;
        /// <summary>
        ///  Number of extra channels (alpha, depth, etc.).
        /// </summary>
        public uint NumExtraChannels;
        /// <summary>
        ///  Animation ticks per second numerator (0 if no animation).
        /// </summary>
        public uint AnimationTpsNumerator;
        /// <summary>
        ///  Animation ticks per second denominator (0 if no animation).
        /// </summary>
        public uint AnimationTpsDenominator;
        /// <summary>
        ///  Number of animation loops (0 = infinite).
        /// </summary>
        public uint AnimationNumLoops;
        /// <summary>
        ///  Preview image width (0 if no preview).
        /// </summary>
        public uint PreviewWidth;
        /// <summary>
        ///  Preview image height (0 if no preview).
        /// </summary>
        public uint PreviewHeight;
        /// <summary>
        ///  Intensity target for HDR (nits).
        /// </summary>
        public float IntensityTarget;
        /// <summary>
        ///  Minimum nits for tone mapping.
        /// </summary>
        public float MinNits;
        /// <summary>
        ///  Whether linear_below is relative to max display luminance.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool RelativeToMaxDisplay;
        /// <summary>
        ///  Linear tone mapping threshold (nits, or ratio if relative_to_max_display).
        /// </summary>
        public float LinearBelow;
        /// <summary>
        ///  Image orientation.
        /// </summary>
        public JxlOrientation Orientation;
        /// <summary>
        ///  Whether alpha is premultiplied.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AlphaPremultiplied;
        /// <summary>
        ///  Whether the image has animation.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool HaveAnimation;
        /// <summary>
        ///  Whether original color profile is used.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool UsesOriginalProfile;
    }

    /// <summary>
    ///  Information about an extra channel.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlExtraChannelInfo
    {
        /// <summary>
        ///  Spot color values (RGBA, only for spot color channels).
        /// </summary>
        public fixed float SpotColor[4];
        /// <summary>
        ///  Bits per sample.
        /// </summary>
        public uint BitsPerSample;
        /// <summary>
        ///  Exponent bits (for float channels).
        /// </summary>
        public uint ExponentBitsPerSample;
        /// <summary>
        ///  Channel name length in bytes (excluding null terminator).
        /// </summary>
        public uint NameLength;
        /// <summary>
        ///  Type of extra channel.
        /// </summary>
        public JxlExtraChannelType ChannelType;
        /// <summary>
        ///  Whether alpha is associated/premultiplied (only for alpha channels).
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AlphaAssociated;
    }

    /// <summary>
    ///  Frame header information.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlFrameHeader
    {
        /// <summary>
        ///  Frame duration in milliseconds (for animation).
        /// </summary>
        public float DurationMs;
        /// <summary>
        ///  Frame width in pixels.
        /// </summary>
        public uint FrameWidth;
        /// <summary>
        ///  Frame height in pixels.
        /// </summary>
        public uint FrameHeight;
        /// <summary>
        ///  Frame name length in bytes. Use jxl_decoder_get_frame_name to get the actual name.
        /// </summary>
        public uint NameLength;
        /// <summary>
        ///  Whether this is the last frame.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool IsLast;
    }

    /// <summary>
    ///  Decoder options.
    ///  All options should be set before decoding begins.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct JxlDecodeOptions
    {
        /// <summary>
        ///  Maximum number of pixels to decode.
        ///  0 = no limit.
        /// </summary>
        public System.UIntPtr PixelLimit;
        /// <summary>
        ///  Desired intensity target for HDR content.
        ///  0 = use default (image's native intensity target).
        /// </summary>
        public float DesiredIntensityTarget;
        /// <summary>
        ///  Progressive decoding mode.
        /// </summary>
        public JxlProgressiveMode ProgressiveMode;
        /// <summary>
        ///  Whether to adjust image orientation based on EXIF data.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool AdjustOrientation;
        /// <summary>
        ///  Whether to render spot colors.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool RenderSpotColors;
        /// <summary>
        ///  Whether to coalesce animation frames.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool Coalescing;
        /// <summary>
        ///  Whether to skip the preview image.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool SkipPreview;
        /// <summary>
        ///  Whether to enable output rendering.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool EnableOutput;
        /// <summary>
        ///  Whether to use high precision mode for decoding.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool HighPrecision;
        /// <summary>
        ///  Whether to premultiply alpha in the output.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool PremultiplyAlpha;
        /// <summary>
        ///  Whether to decode extra channels into separate buffers.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool DecodeExtraChannels;
    }


    /// <summary>
    ///  Status codes returned by decoder functions.
    /// </summary>
    public enum JxlStatus : uint
    {
        /// <summary>
        ///  Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 1,
        /// <summary>
        ///  The decoder needs more input data.
        /// </summary>
        NeedMoreInput = 2,
        /// <summary>
        ///  Invalid argument passed to function.
        /// </summary>
        InvalidArgument = 3,
        /// <summary>
        ///  Buffer too small for output.
        /// </summary>
        BufferTooSmall = 4,
        /// <summary>
        ///  Decoder is in an invalid state for this operation.
        /// </summary>
        InvalidState = 5,
    }

    /// <summary>
    ///  Pixel data format.
    /// </summary>
    public enum JxlDataFormat : uint
    {
        /// <summary>
        ///  8-bit unsigned integer per channel.
        /// </summary>
        Uint8 = 0,
        /// <summary>
        ///  16-bit unsigned integer per channel.
        /// </summary>
        Uint16 = 1,
        /// <summary>
        ///  16-bit float per channel.
        /// </summary>
        Float16 = 2,
        /// <summary>
        ///  32-bit float per channel.
        /// </summary>
        Float32 = 3,
    }

    /// <summary>
    ///  Color channel layout.
    /// </summary>
    public enum JxlColorType : uint
    {
        /// <summary>
        ///  Single grayscale channel.
        /// </summary>
        Grayscale = 0,
        /// <summary>
        ///  Grayscale + alpha.
        /// </summary>
        GrayscaleAlpha = 1,
        /// <summary>
        ///  Red, green, blue.
        /// </summary>
        Rgb = 2,
        /// <summary>
        ///  Red, green, blue, alpha.
        /// </summary>
        Rgba = 3,
        /// <summary>
        ///  Blue, green, red (Windows bitmap order).
        /// </summary>
        Bgr = 4,
        /// <summary>
        ///  Blue, green, red, alpha.
        /// </summary>
        Bgra = 5,
    }

    /// <summary>
    ///  Endianness for multi-byte pixel formats.
    /// </summary>
    public enum JxlEndianness : uint
    {
        /// <summary>
        ///  Use native endianness of the platform.
        /// </summary>
        Native = 0,
        /// <summary>
        ///  Little endian byte order.
        /// </summary>
        LittleEndian = 1,
        /// <summary>
        ///  Big endian byte order.
        /// </summary>
        BigEndian = 2,
    }

    /// <summary>
    ///  Image orientation (EXIF-style).
    /// </summary>
    public enum JxlOrientation : uint
    {
        /// <summary>
        ///  Normal orientation.
        /// </summary>
        Identity = 1,
        /// <summary>
        ///  Flipped horizontally.
        /// </summary>
        FlipHorizontal = 2,
        /// <summary>
        ///  Rotated 180 degrees.
        /// </summary>
        Rotate180 = 3,
        /// <summary>
        ///  Flipped vertically.
        /// </summary>
        FlipVertical = 4,
        /// <summary>
        ///  Transposed (swap x/y) then flipped horizontally.
        /// </summary>
        Transpose = 5,
        /// <summary>
        ///  Rotated 90 degrees clockwise.
        /// </summary>
        Rotate90Cw = 6,
        /// <summary>
        ///  Transposed then flipped vertically.
        /// </summary>
        AntiTranspose = 7,
        /// <summary>
        ///  Rotated 90 degrees counter-clockwise.
        /// </summary>
        Rotate90Ccw = 8,
    }

    /// <summary>
    ///  Progressive decoding mode.
    /// </summary>
    public enum JxlProgressiveMode : uint
    {
        /// <summary>
        ///  Renders all pixels in every call to Process.
        /// </summary>
        Eager = 0,
        /// <summary>
        ///  Renders pixels once passes are completed.
        /// </summary>
        Pass = 1,
        /// <summary>
        ///  Renders pixels only once the final frame is ready.
        /// </summary>
        FullFrame = 2,
    }

    /// <summary>
    ///  Extra channel type.
    /// </summary>
    public enum JxlExtraChannelType : uint
    {
        /// <summary>
        ///  Alpha/transparency channel.
        /// </summary>
        Alpha = 0,
        /// <summary>
        ///  Depth map.
        /// </summary>
        Depth = 1,
        /// <summary>
        ///  Spot color.
        /// </summary>
        SpotColor = 2,
        /// <summary>
        ///  Selection mask.
        /// </summary>
        SelectionMask = 3,
        /// <summary>
        ///  CFA (color filter array) for raw sensor data.
        /// </summary>
        Cfa = 4,
        /// <summary>
        ///  Thermal data.
        /// </summary>
        Thermal = 5,
        /// <summary>
        ///  Non-optional extra channel.
        /// </summary>
        NonOptional = 6,
        /// <summary>
        ///  Optional extra channel.
        /// </summary>
        Optional = 7,
        /// <summary>
        ///  Unknown channel type.
        /// </summary>
        Unknown = 255,
    }

    /// <summary>
    ///  Events returned by the streaming decoder's process function.
    ///  These indicate what stage the decoder has reached.
    /// </summary>
    public enum JxlDecoderEvent : uint
    {
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 0,
        /// <summary>
        ///  The decoder needs more input data. Call `jxl_decoder_append_input`.
        /// </summary>
        NeedMoreInput = 1,
        /// <summary>
        ///  Basic image info is now available. Call `jxl_decoder_get_basic_info`.
        /// </summary>
        HaveBasicInfo = 2,
        /// <summary>
        ///  Frame header is available. Call `jxl_decoder_get_frame_header`.
        /// </summary>
        HaveFrameHeader = 3,
        /// <summary>
        ///  Pixels are available. Call `jxl_decoder_read_pixels` with a buffer.
        /// </summary>
        NeedOutputBuffer = 4,
        /// <summary>
        ///  A frame has been fully decoded.
        /// </summary>
        FrameComplete = 5,
        /// <summary>
        ///  All frames have been decoded. The decoder is finished.
        /// </summary>
        Complete = 6,
    }

    /// <summary>
    ///  Signature check result.
    /// </summary>
    public enum JxlSignature : uint
    {
        /// <summary>
        ///  Not enough data to determine.
        /// </summary>
        NotEnoughBytes = 0,
        /// <summary>
        ///  Not a JPEG XL file.
        /// </summary>
        Invalid = 1,
        /// <summary>
        ///  Valid JPEG XL codestream.
        /// </summary>
        Codestream = 2,
        /// <summary>
        ///  Valid JPEG XL container.
        /// </summary>
        Container = 3,
    }


}
