// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace JpegXL.Net.Native
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "jxlrs";





        /// <summary>
        ///  Returns the library version as a packed integer.
        ///  Format: (major &lt;&lt; 24) | (minor &lt;&lt; 16) | (patch &lt;&lt; 8)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint jxl_version();

        /// <summary>
        ///  Creates a new decoder instance with default options.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern NativeDecoderHandle* jxl_decoder_create();

        /// <summary>
        ///  Creates a new decoder instance with the specified options.
        ///
        ///  This is the preferred way to create a decoder with custom options.
        ///  Options are immutable after creation for efficiency.
        ///
        ///  # Arguments
        ///  * `options` - Pointer to decoder options, or null to use defaults.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        ///
        ///  # Safety
        ///  If `options` is not null, it must point to a valid `JxlDecoderOptionsC` struct.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create_with_options", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern NativeDecoderHandle* jxl_decoder_create_with_options(JxlDecoderOptionsC* options);

        /// <summary>
        ///  Destroys a decoder instance and frees its resources.
        ///
        ///  # Safety
        ///  The decoder pointer must have been created by `jxl_decoder_create`.
        ///  After calling this function, the decoder pointer is invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_destroy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void jxl_decoder_destroy(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Resets the decoder to its initial state, allowing it to decode a new image.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_reset(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Sets the input data for the decoder (one-shot decoding).
        ///
        ///  The decoder copies the data internally, so the caller can free
        ///  the input buffer after this call.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `data` must point to `size` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_set_input(NativeDecoderHandle* decoder, byte* data, System.UIntPtr size);

        /// <summary>
        ///  Appends more input data to the decoder's buffer (streaming decoding).
        ///
        ///  Unlike `jxl_decoder_set_input`, this does not reset the decoder state,
        ///  allowing incremental feeding of data.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `data` must point to `size` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_append_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_append_input(NativeDecoderHandle* decoder, byte* data, System.UIntPtr size);

        /// <summary>
        ///  Processes the current input data and returns the next decoder event.
        ///
        ///  This is the main function for streaming decoding. Call it repeatedly,
        ///  handling each event appropriately:
        ///  - `NeedMoreInput`: Call `jxl_decoder_append_input` with more data
        ///  - `HaveBasicInfo`: Image info is available, call `jxl_decoder_get_basic_info`
        ///  - `HaveFrameHeader`: Frame header is available, call `jxl_decoder_get_frame_header`
        ///  - `NeedOutputBuffer`: Ready to decode pixels, call `jxl_decoder_read_pixels`
        ///  - `FrameComplete`: Frame is done, check for more frames or call again
        ///  - `Complete`: All frames decoded, decoding is finished
        ///  - `Error`: Check `jxl_get_last_error` for details
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_process", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlDecoderEvent jxl_decoder_process(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets the basic image info (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveBasicInfo`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlBasicInfo`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_basic_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_get_basic_info(NativeDecoderHandle* decoder, JxlBasicInfo* info);

        /// <summary>
        ///  Gets the current frame header (streaming API).
        ///
        ///  Only valid after `jxl_decoder_process` returns `HaveFrameHeader`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `header` must point to a writable `JxlFrameHeader`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_frame_header", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_get_frame_header(NativeDecoderHandle* decoder, JxlFrameHeader* header);

        /// <summary>
        ///  Decodes pixels into the provided buffer (streaming API).
        ///
        ///  Call this after `jxl_decoder_process` returns `NeedOutputBuffer`.
        ///  After successful completion, call `jxl_decoder_process` again to
        ///  get `FrameComplete` or continue with the next frame.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `buffer` must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlDecoderEvent jxl_decoder_read_pixels(NativeDecoderHandle* decoder, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Checks if the decoder has more frames to decode.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_has_more_frames", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        internal static extern bool jxl_decoder_has_more_frames(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Calculates the required buffer size for a specific extra channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `index` - The extra channel index (0-based).
        ///
        ///  # Returns
        ///  The required buffer size in bytes, or 0 if invalid.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern System.UIntPtr jxl_decoder_get_extra_channel_buffer_size(NativeDecoderHandle* decoder, uint index);

        /// <summary>
        ///  Decodes pixels with extra channels into separate buffers.
        ///
        ///  The first buffer receives color data (RGB/RGBA/etc.), subsequent buffers
        ///  receive extra channels in order. Set buffer to null to skip that channel.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `color_buffer` - Output buffer for color data.
        ///  * `color_buffer_size` - Size of color buffer in bytes.
        ///  * `extra_buffers` - Array of pointers to extra channel buffers (can contain nulls to skip).
        ///  * `extra_buffer_sizes` - Array of buffer sizes for each extra channel.
        ///  * `num_extra_buffers` - Number of extra buffers provided.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `color_buffer` must be valid for writes of `color_buffer_size` bytes.
        ///  - `extra_buffers` must point to `num_extra_buffers` pointers.
        ///  - Each non-null buffer must be valid for writes of its corresponding size.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_pixels_with_extra_channels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlDecoderEvent jxl_decoder_read_pixels_with_extra_channels(NativeDecoderHandle* decoder, byte* color_buffer, System.UIntPtr color_buffer_size, byte** extra_buffers, System.UIntPtr* extra_buffer_sizes, System.UIntPtr num_extra_buffers);

        /// <summary>
        ///  Sets the desired output pixel format.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_pixel_format", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_set_pixel_format(NativeDecoderHandle* decoder, JxlPixelFormat* format);

        /// <summary>
        ///  Gets the number of extra channels.
        ///
        ///  Must be called after basic info is available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint jxl_decoder_get_extra_channel_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets info about an extra channel.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlExtraChannelInfo`.
        ///  - `index` must be less than the extra channel count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_get_extra_channel_info(NativeDecoderHandle* decoder, uint index, JxlExtraChannelInfo* info);

        /// <summary>
        ///  Calculates the required buffer size for decoded pixels.
        ///
        ///  # Safety
        ///  `decoder` must be valid and basic info must be available (after `HaveBasicInfo` event).
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern System.UIntPtr jxl_decoder_get_buffer_size(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Checks if data appears to be a JPEG XL file.
        ///
        ///  Only needs the first 12 bytes to determine.
        ///
        ///  # Safety
        ///  `data` must be valid for reads of `size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_signature_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlSignature jxl_signature_check(byte* data, System.UIntPtr size);

        /// <summary>
        ///  Gets the last error message.
        ///
        ///  # Arguments
        ///  * `buffer` - Buffer to write the error message to.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The length of the error message (excluding null terminator).
        ///  If the buffer is too small, the message is truncated.
        ///  Returns 0 if there is no error message.
        ///
        ///  # Safety
        ///  The buffer must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_get_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern System.UIntPtr jxl_get_last_error(byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Clears the last error message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_clear_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void jxl_clear_last_error();


    }

    /// <summary>
    ///  Opaque decoder handle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct NativeDecoderHandle
    {
        public fixed byte _private[1];
    }

    /// <summary>
    ///  Pixel format specification.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlPixelFormat
    {
        /// <summary>
        ///  Data format for each channel.
        /// </summary>
        public JxlDataFormat data_format;
        /// <summary>
        ///  Color channel layout.
        /// </summary>
        public JxlColorType color_type;
        /// <summary>
        ///  Endianness for formats &gt; 8 bits.
        /// </summary>
        public JxlEndianness endianness;
    }

    /// <summary>
    ///  Basic image information.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlBasicInfo
    {
        /// <summary>
        ///  Image width in pixels.
        /// </summary>
        public uint width;
        /// <summary>
        ///  Image height in pixels.
        /// </summary>
        public uint height;
        /// <summary>
        ///  Bits per sample for integer formats.
        /// </summary>
        public uint bits_per_sample;
        /// <summary>
        ///  Exponent bits (0 for integer formats, &gt;0 for float).
        /// </summary>
        public uint exponent_bits_per_sample;
        /// <summary>
        ///  Number of color channels (1 for grayscale, 3 for RGB).
        /// </summary>
        public uint num_color_channels;
        /// <summary>
        ///  Number of extra channels (alpha, depth, etc.).
        /// </summary>
        public uint num_extra_channels;
        /// <summary>
        ///  Animation ticks per second numerator (0 if no animation).
        /// </summary>
        public uint animation_tps_numerator;
        /// <summary>
        ///  Animation ticks per second denominator (0 if no animation).
        /// </summary>
        public uint animation_tps_denominator;
        /// <summary>
        ///  Number of animation loops (0 = infinite).
        /// </summary>
        public uint animation_num_loops;
        /// <summary>
        ///  Preview image width (0 if no preview).
        /// </summary>
        public uint preview_width;
        /// <summary>
        ///  Preview image height (0 if no preview).
        /// </summary>
        public uint preview_height;
        /// <summary>
        ///  Intensity target for HDR (nits).
        /// </summary>
        public float intensity_target;
        /// <summary>
        ///  Minimum nits for tone mapping.
        /// </summary>
        public float min_nits;
        /// <summary>
        ///  Image orientation.
        /// </summary>
        public JxlOrientation orientation;
        /// <summary>
        ///  Whether alpha is premultiplied.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool alpha_premultiplied;
        /// <summary>
        ///  Whether the image has animation.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool have_animation;
        /// <summary>
        ///  Whether original color profile is used.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool uses_original_profile;
    }

    /// <summary>
    ///  Information about an extra channel.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlExtraChannelInfo
    {
        /// <summary>
        ///  Spot color values (RGBA, only for spot color channels).
        /// </summary>
        public fixed float spot_color[4];
        /// <summary>
        ///  Bits per sample.
        /// </summary>
        public uint bits_per_sample;
        /// <summary>
        ///  Exponent bits (for float channels).
        /// </summary>
        public uint exponent_bits_per_sample;
        /// <summary>
        ///  Channel name length in bytes (excluding null terminator).
        /// </summary>
        public uint name_length;
        /// <summary>
        ///  Type of extra channel.
        /// </summary>
        public JxlExtraChannelType channel_type;
        /// <summary>
        ///  Whether alpha is premultiplied (only for alpha channels).
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool alpha_premultiplied;
    }

    /// <summary>
    ///  Frame header information.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlFrameHeader
    {
        /// <summary>
        ///  Frame duration in milliseconds (for animation).
        /// </summary>
        public float duration_ms;
        /// <summary>
        ///  Frame width in pixels.
        /// </summary>
        public uint frame_width;
        /// <summary>
        ///  Frame height in pixels.
        /// </summary>
        public uint frame_height;
        /// <summary>
        ///  Frame name length in bytes (excluding null terminator).
        /// </summary>
        public uint name_length;
        /// <summary>
        ///  Whether this is the last frame.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool is_last;
    }

    /// <summary>
    ///  Decoder options (C-compatible struct).
    ///  All options should be set before decoding begins.
    ///  Fields are ordered by size (largest first) to minimize padding.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlDecoderOptionsC
    {
        /// <summary>
        ///  Maximum number of pixels to decode.
        ///  0 = no limit.
        /// </summary>
        public System.UIntPtr pixel_limit;
        /// <summary>
        ///  Desired intensity target for HDR content.
        ///  0 = use default (image's native intensity target).
        /// </summary>
        public float desired_intensity_target;
        /// <summary>
        ///  Progressive decoding mode.
        /// </summary>
        public JxlProgressiveMode progressive_mode;
        /// <summary>
        ///  Whether to adjust image orientation based on EXIF data.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool adjust_orientation;
        /// <summary>
        ///  Whether to render spot colors.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool render_spot_colors;
        /// <summary>
        ///  Whether to coalesce animation frames.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool coalescing;
        /// <summary>
        ///  Whether to skip the preview image.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool skip_preview;
        /// <summary>
        ///  Whether to enable output rendering.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool enable_output;
        /// <summary>
        ///  Whether to use high precision mode for decoding.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool high_precision;
        /// <summary>
        ///  Whether to premultiply alpha in the output.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool premultiply_alpha;
        /// <summary>
        ///  Whether to decode extra channels into separate buffers.
        /// </summary>
        [MarshalAs(UnmanagedType.U1)] public bool decode_extra_channels;
    }


    /// <summary>
    ///  Signature check result.
    /// </summary>
    internal enum JxlSignature : uint
    {
        /// <summary>
        ///  Not enough data to determine.
        /// </summary>
        NotEnoughBytes = 0,
        /// <summary>
        ///  Not a JPEG XL file.
        /// </summary>
        Invalid = 1,
        /// <summary>
        ///  Valid JPEG XL codestream.
        /// </summary>
        Codestream = 2,
        /// <summary>
        ///  Valid JPEG XL container.
        /// </summary>
        Container = 3,
    }

    /// <summary>
    ///  Status codes returned by decoder functions.
    /// </summary>
    internal enum JxlStatus : uint
    {
        /// <summary>
        ///  Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 1,
        /// <summary>
        ///  The decoder needs more input data.
        /// </summary>
        NeedMoreInput = 2,
        /// <summary>
        ///  Invalid argument passed to function.
        /// </summary>
        InvalidArgument = 3,
        /// <summary>
        ///  Buffer too small for output.
        /// </summary>
        BufferTooSmall = 4,
        /// <summary>
        ///  Decoder is in an invalid state for this operation.
        /// </summary>
        InvalidState = 5,
    }

    /// <summary>
    ///  Pixel data format.
    /// </summary>
    internal enum JxlDataFormat : uint
    {
        /// <summary>
        ///  8-bit unsigned integer per channel.
        /// </summary>
        Uint8 = 0,
        /// <summary>
        ///  16-bit unsigned integer per channel.
        /// </summary>
        Uint16 = 1,
        /// <summary>
        ///  16-bit float per channel.
        /// </summary>
        Float16 = 2,
        /// <summary>
        ///  32-bit float per channel.
        /// </summary>
        Float32 = 3,
    }

    /// <summary>
    ///  Color channel layout.
    /// </summary>
    internal enum JxlColorType : uint
    {
        /// <summary>
        ///  Single grayscale channel.
        /// </summary>
        Grayscale = 0,
        /// <summary>
        ///  Grayscale + alpha.
        /// </summary>
        GrayscaleAlpha = 1,
        /// <summary>
        ///  Red, green, blue.
        /// </summary>
        Rgb = 2,
        /// <summary>
        ///  Red, green, blue, alpha.
        /// </summary>
        Rgba = 3,
        /// <summary>
        ///  Blue, green, red (Windows bitmap order).
        /// </summary>
        Bgr = 4,
        /// <summary>
        ///  Blue, green, red, alpha.
        /// </summary>
        Bgra = 5,
    }

    /// <summary>
    ///  Endianness for multi-byte pixel formats.
    /// </summary>
    internal enum JxlEndianness : uint
    {
        /// <summary>
        ///  Use native endianness of the platform.
        /// </summary>
        Native = 0,
        /// <summary>
        ///  Little endian byte order.
        /// </summary>
        LittleEndian = 1,
        /// <summary>
        ///  Big endian byte order.
        /// </summary>
        BigEndian = 2,
    }

    /// <summary>
    ///  Image orientation (EXIF-style).
    /// </summary>
    internal enum JxlOrientation : uint
    {
        /// <summary>
        ///  Normal orientation.
        /// </summary>
        Identity = 1,
        /// <summary>
        ///  Flipped horizontally.
        /// </summary>
        FlipHorizontal = 2,
        /// <summary>
        ///  Rotated 180 degrees.
        /// </summary>
        Rotate180 = 3,
        /// <summary>
        ///  Flipped vertically.
        /// </summary>
        FlipVertical = 4,
        /// <summary>
        ///  Transposed (swap x/y) then flipped horizontally.
        /// </summary>
        Transpose = 5,
        /// <summary>
        ///  Rotated 90 degrees clockwise.
        /// </summary>
        Rotate90Cw = 6,
        /// <summary>
        ///  Transposed then flipped vertically.
        /// </summary>
        AntiTranspose = 7,
        /// <summary>
        ///  Rotated 90 degrees counter-clockwise.
        /// </summary>
        Rotate90Ccw = 8,
    }

    /// <summary>
    ///  Progressive decoding mode.
    /// </summary>
    internal enum JxlProgressiveMode : uint
    {
        /// <summary>
        ///  Renders all pixels in every call to Process.
        /// </summary>
        Eager = 0,
        /// <summary>
        ///  Renders pixels once passes are completed.
        /// </summary>
        Pass = 1,
        /// <summary>
        ///  Renders pixels only once the final frame is ready.
        /// </summary>
        FullFrame = 2,
    }

    /// <summary>
    ///  Extra channel type.
    /// </summary>
    internal enum JxlExtraChannelType : uint
    {
        /// <summary>
        ///  Alpha/transparency channel.
        /// </summary>
        Alpha = 0,
        /// <summary>
        ///  Depth map.
        /// </summary>
        Depth = 1,
        /// <summary>
        ///  Spot color.
        /// </summary>
        SpotColor = 2,
        /// <summary>
        ///  Selection mask.
        /// </summary>
        SelectionMask = 3,
        /// <summary>
        ///  CFA (color filter array) for raw sensor data.
        /// </summary>
        Cfa = 4,
        /// <summary>
        ///  Thermal data.
        /// </summary>
        Thermal = 5,
        /// <summary>
        ///  Non-optional extra channel.
        /// </summary>
        NonOptional = 6,
        /// <summary>
        ///  Optional extra channel.
        /// </summary>
        Optional = 7,
        /// <summary>
        ///  Unknown channel type.
        /// </summary>
        Unknown = 255,
    }

    /// <summary>
    ///  Events returned by the streaming decoder's process function.
    ///  These indicate what stage the decoder has reached.
    /// </summary>
    internal enum JxlDecoderEvent : uint
    {
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 0,
        /// <summary>
        ///  The decoder needs more input data. Call `jxl_decoder_append_input`.
        /// </summary>
        NeedMoreInput = 1,
        /// <summary>
        ///  Basic image info is now available. Call `jxl_decoder_get_basic_info`.
        /// </summary>
        HaveBasicInfo = 2,
        /// <summary>
        ///  Frame header is available. Call `jxl_decoder_get_frame_header`.
        /// </summary>
        HaveFrameHeader = 3,
        /// <summary>
        ///  Pixels are available. Call `jxl_decoder_read_pixels` with a buffer.
        /// </summary>
        NeedOutputBuffer = 4,
        /// <summary>
        ///  A frame has been fully decoded.
        /// </summary>
        FrameComplete = 5,
        /// <summary>
        ///  All frames have been decoded. The decoder is finished.
        /// </summary>
        Complete = 6,
    }


}
