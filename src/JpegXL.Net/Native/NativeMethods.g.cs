// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace JpegXL.Net.Native
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "jxlrs";





        /// <summary>
        ///  Returns the library version as a packed integer.
        ///  Format: (major &lt;&lt; 24) | (minor &lt;&lt; 16) | (patch &lt;&lt; 8)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint jxl_version();

        /// <summary>
        ///  Creates a new decoder instance.
        ///
        ///  # Returns
        ///  A pointer to the decoder, or null on allocation failure.
        ///  The decoder must be destroyed with `jxl_decoder_destroy`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_create", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern NativeDecoderHandle* jxl_decoder_create();

        /// <summary>
        ///  Destroys a decoder instance and frees its resources.
        ///
        ///  # Safety
        ///  The decoder pointer must have been created by `jxl_decoder_create`.
        ///  After calling this function, the decoder pointer is invalid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_destroy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void jxl_decoder_destroy(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Resets the decoder to its initial state, allowing it to decode a new image.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_reset(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Sets the input data for the decoder (one-shot decoding).
        ///
        ///  The decoder copies the data internally, so the caller can free
        ///  the input buffer after this call.
        ///
        ///  # Safety
        ///  - `decoder` must be a valid decoder pointer.
        ///  - `data` must point to `size` readable bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_set_input(NativeDecoderHandle* decoder, byte* data, System.UIntPtr size);

        /// <summary>
        ///  Sets the desired output pixel format.
        ///
        ///  # Safety
        ///  The decoder pointer must be valid.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_set_pixel_format", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_set_pixel_format(NativeDecoderHandle* decoder, JxlPixelFormat* format);

        /// <summary>
        ///  Decodes the image header and retrieves basic info.
        ///
        ///  This must be called before `jxl_decoder_get_pixels`.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlBasicInfo`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_read_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_read_info(NativeDecoderHandle* decoder, JxlBasicInfo* info);

        /// <summary>
        ///  Gets the number of extra channels.
        ///
        ///  Must be called after `jxl_decoder_read_info`.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern uint jxl_decoder_get_extra_channel_count(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Gets info about an extra channel.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `info` must point to a writable `JxlExtraChannelInfo`.
        ///  - `index` must be less than the extra channel count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_extra_channel_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_get_extra_channel_info(NativeDecoderHandle* decoder, uint index, JxlExtraChannelInfo* info);

        /// <summary>
        ///  Calculates the required buffer size for decoded pixels.
        ///
        ///  # Safety
        ///  `decoder` must be valid and `jxl_decoder_read_info` must have been called.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern System.UIntPtr jxl_decoder_get_buffer_size(NativeDecoderHandle* decoder);

        /// <summary>
        ///  Decodes pixels into the provided buffer.
        ///
        ///  # Arguments
        ///  * `decoder` - The decoder instance.
        ///  * `buffer` - Output buffer for pixel data.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Safety
        ///  - `decoder` must be valid.
        ///  - `buffer` must be valid for writes of `buffer_size` bytes.
        ///  - `jxl_decoder_read_info` must have been called first.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_decoder_get_pixels", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlStatus jxl_decoder_get_pixels(NativeDecoderHandle* decoder, byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Checks if data appears to be a JPEG XL file.
        ///
        ///  Only needs the first 12 bytes to determine.
        ///
        ///  # Safety
        ///  `data` must be valid for reads of `size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_signature_check", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern JxlSignature jxl_signature_check(byte* data, System.UIntPtr size);

        /// <summary>
        ///  Gets the last error message.
        ///
        ///  # Arguments
        ///  * `buffer` - Buffer to write the error message to.
        ///  * `buffer_size` - Size of the buffer in bytes.
        ///
        ///  # Returns
        ///  The length of the error message (excluding null terminator).
        ///  If the buffer is too small, the message is truncated.
        ///  Returns 0 if there is no error message.
        ///
        ///  # Safety
        ///  The buffer must be valid for writes of `buffer_size` bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_get_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern System.UIntPtr jxl_get_last_error(byte* buffer, System.UIntPtr buffer_size);

        /// <summary>
        ///  Clears the last error message.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "jxl_clear_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void jxl_clear_last_error();


    }

    /// <summary>
    ///  Opaque decoder handle.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct NativeDecoderHandle
    {
        public fixed byte _private[1];
    }

    /// <summary>
    ///  Pixel format specification.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlPixelFormat
    {
        /// <summary>
        ///  Data format for each channel.
        /// </summary>
        public JxlDataFormat data_format;
        /// <summary>
        ///  Color channel layout.
        /// </summary>
        public JxlColorType color_type;
        /// <summary>
        ///  Endianness for formats &gt; 8 bits.
        /// </summary>
        public JxlEndianness endianness;
    }

    /// <summary>
    ///  Basic image information.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlBasicInfo
    {
        /// <summary>
        ///  Image width in pixels.
        /// </summary>
        public uint width;
        /// <summary>
        ///  Image height in pixels.
        /// </summary>
        public uint height;
        /// <summary>
        ///  Bits per sample for integer formats.
        /// </summary>
        public uint bits_per_sample;
        /// <summary>
        ///  Exponent bits (0 for integer formats, &gt;0 for float).
        /// </summary>
        public uint exponent_bits_per_sample;
        /// <summary>
        ///  Number of color channels (1 for grayscale, 3 for RGB).
        /// </summary>
        public uint num_color_channels;
        /// <summary>
        ///  Number of extra channels (alpha, depth, etc.).
        /// </summary>
        public uint num_extra_channels;
        /// <summary>
        ///  Whether alpha is premultiplied (0 = no, 1 = yes).
        /// </summary>
        public int alpha_premultiplied;
        /// <summary>
        ///  Image orientation.
        /// </summary>
        public JxlOrientation orientation;
        /// <summary>
        ///  Whether the image has animation (0 = no, 1 = yes).
        /// </summary>
        public int have_animation;
        /// <summary>
        ///  Animation ticks per second numerator (0 if no animation).
        /// </summary>
        public uint animation_tps_numerator;
        /// <summary>
        ///  Animation ticks per second denominator (0 if no animation).
        /// </summary>
        public uint animation_tps_denominator;
        /// <summary>
        ///  Number of animation loops (0 = infinite).
        /// </summary>
        public uint animation_num_loops;
        /// <summary>
        ///  Whether original color profile is used (0 = no, 1 = yes).
        /// </summary>
        public int uses_original_profile;
        /// <summary>
        ///  Preview image width (0 if no preview).
        /// </summary>
        public uint preview_width;
        /// <summary>
        ///  Preview image height (0 if no preview).
        /// </summary>
        public uint preview_height;
        /// <summary>
        ///  Intensity target for HDR (nits).
        /// </summary>
        public float intensity_target;
        /// <summary>
        ///  Minimum nits for tone mapping.
        /// </summary>
        public float min_nits;
    }

    /// <summary>
    ///  Information about an extra channel.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct JxlExtraChannelInfo
    {
        /// <summary>
        ///  Type of extra channel.
        /// </summary>
        public JxlExtraChannelType channel_type;
        /// <summary>
        ///  Bits per sample.
        /// </summary>
        public uint bits_per_sample;
        /// <summary>
        ///  Exponent bits (for float channels).
        /// </summary>
        public uint exponent_bits_per_sample;
        /// <summary>
        ///  Whether alpha is premultiplied (only for alpha channels).
        /// </summary>
        public int alpha_premultiplied;
        /// <summary>
        ///  Spot color values (RGBA, only for spot color channels).
        /// </summary>
        public fixed float spot_color[4];
        /// <summary>
        ///  Channel name length in bytes (excluding null terminator).
        /// </summary>
        public uint name_length;
    }


    /// <summary>
    ///  Signature check result.
    /// </summary>
    internal enum JxlSignature : uint
    {
        /// <summary>
        ///  Not enough data to determine.
        /// </summary>
        NotEnoughBytes = 0,
        /// <summary>
        ///  Not a JPEG XL file.
        /// </summary>
        Invalid = 1,
        /// <summary>
        ///  Valid JPEG XL codestream.
        /// </summary>
        Codestream = 2,
        /// <summary>
        ///  Valid JPEG XL container.
        /// </summary>
        Container = 3,
    }

    /// <summary>
    ///  Status codes returned by decoder functions.
    /// </summary>
    internal enum JxlStatus : uint
    {
        /// <summary>
        ///  Operation completed successfully.
        /// </summary>
        Success = 0,
        /// <summary>
        ///  An error occurred. Call `jxl_get_last_error` for details.
        /// </summary>
        Error = 1,
        /// <summary>
        ///  The decoder needs more input data.
        /// </summary>
        NeedMoreInput = 2,
        /// <summary>
        ///  Invalid argument passed to function.
        /// </summary>
        InvalidArgument = 3,
        /// <summary>
        ///  Buffer too small for output.
        /// </summary>
        BufferTooSmall = 4,
        /// <summary>
        ///  Decoder is in an invalid state for this operation.
        /// </summary>
        InvalidState = 5,
    }

    /// <summary>
    ///  Pixel data format.
    /// </summary>
    internal enum JxlDataFormat : uint
    {
        /// <summary>
        ///  8-bit unsigned integer per channel.
        /// </summary>
        Uint8 = 0,
        /// <summary>
        ///  16-bit unsigned integer per channel.
        /// </summary>
        Uint16 = 1,
        /// <summary>
        ///  16-bit float per channel.
        /// </summary>
        Float16 = 2,
        /// <summary>
        ///  32-bit float per channel.
        /// </summary>
        Float32 = 3,
    }

    /// <summary>
    ///  Color channel layout.
    /// </summary>
    internal enum JxlColorType : uint
    {
        /// <summary>
        ///  Single grayscale channel.
        /// </summary>
        Grayscale = 0,
        /// <summary>
        ///  Grayscale + alpha.
        /// </summary>
        GrayscaleAlpha = 1,
        /// <summary>
        ///  Red, green, blue.
        /// </summary>
        Rgb = 2,
        /// <summary>
        ///  Red, green, blue, alpha.
        /// </summary>
        Rgba = 3,
        /// <summary>
        ///  Blue, green, red (Windows bitmap order).
        /// </summary>
        Bgr = 4,
        /// <summary>
        ///  Blue, green, red, alpha.
        /// </summary>
        Bgra = 5,
    }

    /// <summary>
    ///  Endianness for multi-byte pixel formats.
    /// </summary>
    internal enum JxlEndianness : uint
    {
        /// <summary>
        ///  Use native endianness of the platform.
        /// </summary>
        Native = 0,
        /// <summary>
        ///  Little endian byte order.
        /// </summary>
        LittleEndian = 1,
        /// <summary>
        ///  Big endian byte order.
        /// </summary>
        BigEndian = 2,
    }

    /// <summary>
    ///  Image orientation (EXIF-style).
    /// </summary>
    internal enum JxlOrientation : uint
    {
        /// <summary>
        ///  Normal orientation.
        /// </summary>
        Identity = 1,
        /// <summary>
        ///  Flipped horizontally.
        /// </summary>
        FlipHorizontal = 2,
        /// <summary>
        ///  Rotated 180 degrees.
        /// </summary>
        Rotate180 = 3,
        /// <summary>
        ///  Flipped vertically.
        /// </summary>
        FlipVertical = 4,
        /// <summary>
        ///  Transposed (swap x/y) then flipped horizontally.
        /// </summary>
        Transpose = 5,
        /// <summary>
        ///  Rotated 90 degrees clockwise.
        /// </summary>
        Rotate90Cw = 6,
        /// <summary>
        ///  Transposed then flipped vertically.
        /// </summary>
        AntiTranspose = 7,
        /// <summary>
        ///  Rotated 90 degrees counter-clockwise.
        /// </summary>
        Rotate90Ccw = 8,
    }

    /// <summary>
    ///  Extra channel type.
    /// </summary>
    internal enum JxlExtraChannelType : uint
    {
        /// <summary>
        ///  Alpha/transparency channel.
        /// </summary>
        Alpha = 0,
        /// <summary>
        ///  Depth map.
        /// </summary>
        Depth = 1,
        /// <summary>
        ///  Spot color.
        /// </summary>
        SpotColor = 2,
        /// <summary>
        ///  Selection mask.
        /// </summary>
        SelectionMask = 3,
        /// <summary>
        ///  CFA (color filter array) for raw sensor data.
        /// </summary>
        Cfa = 4,
        /// <summary>
        ///  Thermal data.
        /// </summary>
        Thermal = 5,
        /// <summary>
        ///  Non-optional extra channel.
        /// </summary>
        NonOptional = 6,
        /// <summary>
        ///  Optional extra channel.
        /// </summary>
        Optional = 7,
        /// <summary>
        ///  Unknown channel type.
        /// </summary>
        Unknown = 255,
    }


}
